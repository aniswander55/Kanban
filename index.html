<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent Message Data Engine - Network Workflow</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 10px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        h1 {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #2c3e50;
            font-size: 2.5rem;
            font-weight: bold;
            cursor: move;
            user-select: none;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            border: 1px solid transparent;
            transition: all 0.3s ease;
            min-width: 200px;
            text-align: center;
        }
        
        h1:hover {
            border-color: #667eea;
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        h1.dragging {
            opacity: 0.8;
            z-index: 1001;
            cursor: grabbing;
        }
        
        h1.resizing {
            cursor: nw-resize;
        }
        
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 15px;
            height: 15px;
            background: #667eea;
            cursor: nw-resize;
            border-radius: 0 0 10px 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        h1:hover .resize-handle {
            opacity: 1;
        }
        
        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 1002;
            min-width: 150px;
            display: none;
        }
        
        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s ease;
        }
        
        .context-menu-separator {
            height: 1px;
            background: #eee;
            margin: 5px 0;
        }
        
        .context-menu-item:last-child {
            border-bottom: none;
        }
        
        .context-menu-item:hover {
            background-color: #f8f9fa;
        }
        
        .editing-input {
            background: transparent;
            border: none;
            outline: none;
            font-size: inherit;
            font-weight: inherit;
            color: inherit;
            text-align: center;
            width: 100%;
            font-family: inherit;
        }
        
        .workflow-container {
            position: relative;
            width: 100%;
            height: 700px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            border-radius: 20px;
            overflow: visible;
            z-index: 1;
        }
        
        .central-engine {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 40px;
            border-radius: 50%;
            width: 200px;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: bold;
            font-size: 16px;
            line-height: 1.2;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            z-index: 10;
            border: 4px solid white;
            cursor: move;
            user-select: none;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        .central-engine.dragging {
            opacity: 0.8;
            z-index: 1000;
            cursor: grabbing;
        }
        
        .network-node {
            position: absolute;
            background: white;
            border-radius: 50%;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            cursor: move;
            border: 3px solid transparent;
            user-select: none;
            width: 80px;
            height: 80px;
        }
        
        .network-node:hover {
            border-color: #667eea;
            transform: scale(1.1);
        }
        
        .network-node.dragging {
            opacity: 0.8;
            z-index: 1000;
            cursor: grabbing;
        }
        
        .network-node i {
            font-size: 24px;
            color: #667eea;
            pointer-events: none;
        }
        
        .node-label {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 10px;
            color: #2c3e50;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            pointer-events: none;
            cursor: move;
        }
        
        .text-box {
            position: absolute;
            background: white;
            padding: 8px 12px;
            border-radius: 15px;
            cursor: move;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 3px solid white;
            white-space: normal;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            max-width: 300px;
            min-width: 100px;
            min-height: 30px;
            user-select: none;
            z-index: 15;
            line-height: 1.4;
        }
        
        .text-box.dragging {
            opacity: 0.8;
            z-index: 1000;
            cursor: grabbing;
        }
        
        .custom-label-box {
            border: 3px solid white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .custom-label-box.dragging {
            opacity: 0.8;
            z-index: 1000;
            cursor: grabbing;
        }
        
        /* Resize handles */
        .resize-handle {
            position: absolute;
            background: #3498db;
            border: 1px solid #2980b9;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .resize-handle:hover {
            opacity: 1;
        }
        
        .resize-handle.nw {
            top: -5px;
            left: -5px;
            width: 10px;
            height: 10px;
            cursor: nw-resize;
        }
        
        .resize-handle.ne {
            top: -5px;
            right: -5px;
            width: 10px;
            height: 10px;
            cursor: ne-resize;
        }
        
        .resize-handle.sw {
            bottom: -5px;
            left: -5px;
            width: 10px;
            height: 10px;
            cursor: sw-resize;
        }
        
        .resize-handle.se {
            bottom: -5px;
            right: -5px;
            width: 10px;
            height: 10px;
            cursor: se-resize;
        }
        
        .resizable:hover .resize-handle {
            opacity: 1;
        }
        
        .node-label.dragging {
            opacity: 0.8;
            z-index: 1000;
            cursor: grabbing;
        }
        
        .smart-tasks {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #e74c3c;
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 8px 30px rgba(231, 76, 60, 0.4);
            z-index: 20;
            opacity: 1;
            transition: opacity 0.5s ease;
            border: 3px solid white;
            cursor: move;
            user-select: none;
        }
        
        .smart-tasks.dragging {
            opacity: 0.8;
            z-index: 1000;
            cursor: grabbing;
        }
        
        .controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .control-btn {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .control-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }
        
        .custom-label-box {
            position: absolute;
            width: 120px;
            height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: move;
            user-select: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .custom-label-box.dragging {
            opacity: 0.8;
            z-index: 1000;
            cursor: grabbing;
        }
        
        .custom-label-box i {
            font-size: 20px;
            color: white;
            margin-bottom: 5px;
        }
        
        .custom-label-box div {
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background-color: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: modalSlideIn 0.3s ease-out;
        }
        
        .modal-content h3 {
            margin-bottom: 20px;
            color: #2c3e50;
            text-align: center;
            position: relative;
        }
        
        .modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            color: #333;
        }
        
        /* Color Themes Styling */
        .color-themes-section {
            margin-bottom: 20px;
        }
        
        .color-themes-section h4 {
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 16px;
        }
        
        .color-themes {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .theme-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }
        
        .theme-option:hover {
            border-color: #3498db;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
        }
        
        .theme-option.selected {
            border-color: #3498db;
            background: #f8f9fa;
        }
        
        .theme-preview {
            display: flex;
            gap: 2px;
            margin-bottom: 8px;
        }
        
        .theme-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        
        .theme-option span {
            font-size: 12px;
            color: #2c3e50;
            font-weight: 500;
        }
        
        /* Line System Styling */
        .line-type-selector {
            margin-bottom: 20px;
        }
        
        .line-type-selector h4 {
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 16px;
        }
        
        .line-types {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .line-type-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }
        
        .line-type-option:hover {
            border-color: #3498db;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
        }
        
        .line-type-option.selected {
            border-color: #3498db;
            background: #f8f9fa;
        }
        
        .line-preview {
            width: 60px;
            height: 20px;
            margin-bottom: 8px;
            position: relative;
        }
        
        .straight-line {
            background: linear-gradient(to right, #2c3e50 0%, #2c3e50 100%);
            height: 2px;
            margin-top: 9px;
        }
        
        .curved-line {
            background: none;
            border: none;
            height: 20px;
            width: 60px;
            position: relative;
        }
        
        .curved-line::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 60 20'%3E%3Cpath d='M 0,20 Q 30,0 60,20' stroke='%232c3e50' stroke-width='2' fill='none'/%3E%3C/svg%3E") no-repeat center;
            background-size: contain;
        }
        
        .arrow-line {
            background: linear-gradient(to right, #2c3e50 0%, #2c3e50 80%, transparent 80%);
            height: 2px;
            margin-top: 9px;
            position: relative;
        }
        
        .arrow-line::after {
            content: '';
            position: absolute;
            right: 0;
            top: -3px;
            width: 0;
            height: 0;
            border-left: 6px solid #2c3e50;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
        }
        
        .dashed-line {
            background: repeating-linear-gradient(to right, #2c3e50 0px, #2c3e50 4px, transparent 4px, transparent 8px);
            height: 2px;
            margin-top: 9px;
        }
        
        .dotted-line {
            background: repeating-linear-gradient(to right, #2c3e50 0px, #2c3e50 2px, transparent 2px, transparent 4px);
            height: 2px;
            margin-top: 9px;
        }
        
        .zigzag-line {
            background: none;
            position: relative;
        }
        
        .zigzag-line::before {
            content: '';
            position: absolute;
            top: 9px;
            left: 0;
            width: 60px;
            height: 2px;
            background: linear-gradient(45deg, #2c3e50 25%, transparent 25%), 
                        linear-gradient(-45deg, #2c3e50 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #2c3e50 75%), 
                        linear-gradient(-45deg, transparent 75%, #2c3e50 75%);
            background-size: 8px 8px;
            background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
        }
        
        .circle-line {
            background: none;
            border: 2px solid #2c3e50;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            margin: 0 auto;
        }
        
        .square-line {
            background: none;
            border: 2px solid #2c3e50;
            width: 40px;
            height: 40px;
            margin: 0 auto;
        }
        
        .line-type-option span {
            font-size: 12px;
            color: #2c3e50;
            font-weight: 500;
        }
        
        .line-customization {
            margin-bottom: 20px;
        }
        
        .customization-group {
            display: flex;
            align-items: center;
            margin: 15px 0;
        }
        
        .customization-group label {
            flex: 1;
            margin-right: 15px;
            color: #2c3e50;
            font-weight: 500;
        }
        
        .customization-group input[type="color"] {
            width: 60px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        
        .customization-group select {
            width: 100px;
            padding: 8px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            font-size: 14px;
        }
        
        /* Line Element Styling */
        .workflow-line {
            position: absolute;
            z-index: 10;
            cursor: move;
            pointer-events: all;
            overflow: visible;
            transform-origin: center center;
            padding: 0;
        }
        
        .workflow-line .line-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* Shape-specific container sizing - allow resizing */
        .workflow-line[data-line-type="circle"],
        .workflow-line[data-line-type="square"] {
            min-width: 20px;
            min-height: 20px;
        }
        
        /* Line-specific container sizing - allow resizing */
        .workflow-line:not([data-line-type="circle"]):not([data-line-type="square"]) {
            min-width: 5px;
            min-height: 2px;
        }
        
        .workflow-line:hover {
            filter: brightness(1.2);
        }
        
        .workflow-line.selected {
            filter: brightness(1.3);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }
        
        .line-endpoint {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #3498db;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            z-index: 11;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .workflow-line.selected .line-endpoint {
            opacity: 1;
        }
        
        .line-endpoint:hover {
            background: #2980b9;
            transform: scale(1.2);
        }
        
        .curve-control {
            background: #e74c3c !important;
            border: 2px solid white !important;
        }
        
        .workflow-line.selected .curve-control {
            opacity: 1 !important;
        }
        
        .curve-control:hover {
            background: #c0392b !important;
            transform: scale(1.2) !important;
        }
        
        .direction-control {
            background: #f39c12 !important;
            border: 2px solid white !important;
        }
        
        .workflow-line.selected .direction-control {
            opacity: 1 !important;
        }
        
        .direction-control:hover {
            background: #e67e22 !important;
            transform: scale(1.2) !important;
        }
        
        .rotation-control {
            background: #9b59b6 !important;
            border: 2px solid white !important;
            width: 12px !important;
            height: 12px !important;
        }
        
        .workflow-line.selected .rotation-control {
            opacity: 1 !important;
        }
        
        .rotation-control:hover {
            background: #8e44ad !important;
            transform: translate(-50%, -50%) scale(1.2) !important;
        }
        
        .modal-content input,
        .modal-content select {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            font-size: 16px;
        }
        
        .modal-content input:focus,
        .modal-content select:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .icon-library,
        .shape-selector,
        .color-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
        }
        
        .icon-library i,
        .shape-selector .shape-option,
        .color-selector .color-option {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 18px;
        }
        
        .icon-library i:hover,
        .shape-selector .shape-option:hover,
        .color-selector .color-option:hover {
            border-color: #3498db;
            transform: scale(1.1);
        }
        
        .icon-library i.selected,
        .shape-selector .shape-option.selected,
        .color-selector .color-option.selected {
            border-color: #3498db;
            background-color: #3498db;
            color: white;
        }
        
        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .modal-buttons button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .modal-buttons button:first-child {
            background: #3498db;
            color: white;
        }
        
        .modal-buttons button:last-child {
            background: #95a5a6;
            color: white;
        }
        
        .modal-buttons button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .color-input-group {
            display: flex;
            align-items: center;
            margin: 15px 0;
        }
        
        .color-input-group label {
            flex: 1;
            margin-right: 15px;
            color: #2c3e50;
            font-weight: 500;
        }
        
        .color-input-group input[type="color"] {
            width: 60px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        
        /* Context menu styles */
        .context-menu {
            display: none;
            position: absolute;
            z-index: 10000;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            padding: 8px 0;
            min-width: 200px;
        }
        
        .context-menu-item {
            padding: 12px 20px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            color: #2c3e50;
            font-weight: 500;
        }
        
        .context-menu-item:hover {
            background-color: #ecf0f1;
        }
        
        .context-menu-item:first-child {
            border-radius: 8px 8px 0 0;
        }
        
        .context-menu-item:last-child {
            border-radius: 0 0 8px 8px;
        }
        
        /* Editing input styles */
        .editing-input {
            background: transparent;
            border: none;
            outline: none;
            font-size: inherit;
            font-weight: inherit;
            color: inherit;
            text-align: center;
            width: 100%;
            min-width: 60px;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background-color: white;
            margin: 0;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1001;
        }
        
        .modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            color: #333;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .workflow-container {
                height: 500px;
            }
            
            .central-engine {
                width: 150px;
                height: 150px;
                padding: 25px;
                font-size: 14px;
            }
            
            .network-node {
                width: 60px;
                height: 60px;
            }
            
            .network-node i {
                font-size: 18px;
            }
            
            .node-label {
                font-size: 10px;
                padding: 6px 10px;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <h1 class="workflow-title" id="workflowTitle">
            Intelligent Message Data Engine
            <div class="resize-handle"></div>
        </h1>
        
        <div class="workflow-container">
            <!-- Central Engine -->
            <div class="central-engine">
                INTELLIGENT MESSAGE DATA ENGINE
            </div>
            
            <!-- Network Nodes with Work Icons and Labels -->
            <div class="network-node node-1" data-step="1">
                <i class="fas fa-bullseye"></i>
            </div>
            
            <div class="network-node node-2" data-step="2">
                <i class="fas fa-database"></i>
            </div>
            
            <div class="network-node node-3" data-step="3">
                <i class="fas fa-users"></i>
            </div>
            
            <div class="network-node node-4" data-step="4">
                <i class="fas fa-address-book"></i>
            </div>
            
            <div class="network-node node-5" data-step="5">
                <i class="fas fa-link"></i>
            </div>
            
            <div class="network-node node-6" data-step="6">
                <i class="fas fa-handshake"></i>
            </div>
            
            <div class="network-node node-7" data-step="7">
                <i class="fas fa-envelope"></i>
            </div>
            
            <!-- Smart Tasks (Final Outcome) -->
            <div class="smart-tasks" id="smartTasks">
                <i class="fas fa-tasks" style="font-size: 24px; margin-bottom: 10px; display: block;"></i>
                SMART TASKS
            </div>
            
            <!-- Controls Panel -->
            <div class="controls-panel">
                <button class="control-btn" id="startBtn">Start</button>
                <button class="control-btn" id="resetBtn">Reset</button>
                <button class="control-btn" id="saveBtn">Save Layout</button>
                <button class="control-btn" id="loadBtn">Load Layout</button>
            </div>
        </div>
    </div>

    <!-- Icon Creation Modal -->
    <div id="iconModal" class="modal">
        <div class="modal-content">
            <h3>Create New Icon</h3>
            <button class="modal-close" onclick="closeModal('iconModal')">&times;</button>
            <div class="icon-library">
                <i class="fas fa-star" data-icon="fas fa-star"></i>
                <i class="fas fa-heart" data-icon="fas fa-heart"></i>
                <i class="fas fa-flag" data-icon="fas fa-flag"></i>
                <i class="fas fa-bell" data-icon="fas fa-bell"></i>
                <i class="fas fa-bookmark" data-icon="fas fa-bookmark"></i>
                <i class="fas fa-gem" data-icon="fas fa-gem"></i>
                <i class="fas fa-cog" data-icon="fas fa-cog"></i>
                <i class="fas fa-lightbulb" data-icon="fas fa-lightbulb"></i>
                <i class="fas fa-rocket" data-icon="fas fa-rocket"></i>
                <i class="fas fa-shield-alt" data-icon="fas fa-shield-alt"></i>
                <i class="fas fa-clock" data-icon="fas fa-clock"></i>
                <i class="fas fa-map-marker-alt" data-icon="fas fa-map-marker-alt"></i>
            </div>
            <div class="modal-buttons">
                <button id="createIcon">Create</button>
                <button id="cancelIcon">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Label Box Creation Modal -->
    <div id="labelBoxModal" class="modal">
        <div class="modal-content">
            <h3>Create New Label Box</h3>
            <button class="modal-close" onclick="closeModal('labelBoxModal')">&times;</button>
            <input type="text" id="labelBoxName" placeholder="Enter label name">
            <select id="labelBoxFontSize">
                <option value="10px">10px</option>
                <option value="12px" selected>12px</option>
                <option value="14px">14px</option>
                <option value="16px">16px</option>
                <option value="18px">18px</option>
                <option value="20px">20px</option>
                <option value="24px">24px</option>
            </select>
            <div class="shape-selector">
                <div class="shape-option" data-shape="circle">●</div>
                <div class="shape-option" data-shape="square">■</div>
                <div class="shape-option" data-shape="rectangle">▬</div>
                <div class="shape-option" data-shape="rounded-rectangle">▢</div>
                <div class="shape-option" data-shape="diamond">◆</div>
                <div class="shape-option" data-shape="hexagon">⬡</div>
                <div class="shape-option" data-shape="triangle">▲</div>
            </div>
            <div class="icon-library">
                <i class="fas fa-star" data-icon="fas fa-star"></i>
                <i class="fas fa-heart" data-icon="fas fa-heart"></i>
                <i class="fas fa-flag" data-icon="fas fa-flag"></i>
                <i class="fas fa-bell" data-icon="fas fa-bell"></i>
                <i class="fas fa-tasks" data-icon="fas fa-tasks"></i>
            </div>
            <div class="color-selector">
                <div class="color-option" data-color="#667eea" style="background: #667eea;"></div>
                <div class="color-option" data-color="#e74c3c" style="background: #e74c3c;"></div>
                <div class="color-option" data-color="#2ecc71" style="background: #2ecc71;"></div>
                <div class="color-option" data-color="#f39c12" style="background: #f39c12;"></div>
                <div class="color-option" data-color="#9b59b6" style="background: #9b59b6;"></div>
                <div class="color-option" data-color="#1abc9c" style="background: #1abc9c;"></div>
            </div>
            <div class="modal-buttons">
                <button id="createLabelBox">Create</button>
                <button id="cancelLabelBox">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Text Box Creation Modal -->
    <div id="textBoxModal" class="modal">
        <div class="modal-content">
            <h3>Create New Text Box</h3>
            <button class="modal-close" onclick="closeModal('textBoxModal')">&times;</button>
            <textarea id="textBoxContent" placeholder="Enter text content" rows="4" style="width: 100%; min-height: 80px; resize: vertical; font-family: inherit; font-size: inherit; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px;"></textarea>
            <select id="textBoxFontSize">
                <option value="12px">12px</option>
                <option value="14px">14px</option>
                <option value="16px">16px</option>
                <option value="18px">18px</option>
                <option value="20px">20px</option>
                <option value="24px">24px</option>
            </select>
            <select id="textBoxFontFamily">
                <option value="Arial, sans-serif">Arial</option>
                <option value="Times New Roman, serif">Times New Roman</option>
                <option value="Courier New, monospace">Courier New</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="Verdana, sans-serif">Verdana</option>
            </select>
            <input type="color" id="textBoxFontColor" value="#2c3e50">
            <div class="modal-buttons">
                <button id="createTextBox">Create</button>
                <button id="cancelTextBox">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Background Color Modal -->
    <div id="bgColorModal" class="modal">
        <div class="modal-content">
            <h3>Edit Background Colors</h3>
            <button class="modal-close" onclick="closeModal('bgColorModal')">&times;</button>
            
            <!-- Color Themes Section -->
            <div class="color-themes-section">
                <h4>Quick Themes</h4>
                <div class="color-themes">
                    <div class="theme-option" data-theme="default">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #fa709a;"></div>
                            <div class="theme-color" style="background: #667eea;"></div>
                            <div class="theme-color" style="background: #e74c3c;"></div>
                        </div>
                        <span>Default</span>
                    </div>
                    <div class="theme-option" data-theme="ocean">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #667eea;"></div>
                            <div class="theme-color" style="background: #764ba2;"></div>
                            <div class="theme-color" style="background: #f093fb;"></div>
                        </div>
                        <span>Ocean</span>
                    </div>
                    <div class="theme-option" data-theme="sunset">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #ff9a9e;"></div>
                            <div class="theme-color" style="background: #fecfef;"></div>
                            <div class="theme-color" style="background: #fecfef;"></div>
                        </div>
                        <span>Sunset</span>
                    </div>
                    <div class="theme-option" data-theme="forest">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #56ab2f;"></div>
                            <div class="theme-color" style="background: #a8e6cf;"></div>
                            <div class="theme-color" style="background: #ffd3a5;"></div>
                        </div>
                        <span>Forest</span>
                    </div>
                    <div class="theme-option" data-theme="fire">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #ff416c;"></div>
                            <div class="theme-color" style="background: #ff4b2b;"></div>
                            <div class="theme-color" style="background: #ff6b6b;"></div>
                        </div>
                        <span>Fire</span>
                    </div>
                    <div class="theme-option" data-theme="purple">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #667eea;"></div>
                            <div class="theme-color" style="background: #764ba2;"></div>
                            <div class="theme-color" style="background: #f093fb;"></div>
                        </div>
                        <span>Purple</span>
                    </div>
                    <div class="theme-option" data-theme="midnight">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #2c3e50;"></div>
                            <div class="theme-color" style="background: #34495e;"></div>
                            <div class="theme-color" style="background: #3498db;"></div>
                        </div>
                        <span>Midnight</span>
                    </div>
                    <div class="theme-option" data-theme="aurora">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #00c9ff;"></div>
                            <div class="theme-color" style="background: #92fe9d;"></div>
                            <div class="theme-color" style="background: #ff9a9e;"></div>
                        </div>
                        <span>Aurora</span>
                    </div>
                    <div class="theme-option" data-theme="golden">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #f7971e;"></div>
                            <div class="theme-color" style="background: #ffd200;"></div>
                            <div class="theme-color" style="background: #ff6b6b;"></div>
                        </div>
                        <span>Golden</span>
                    </div>
                    <div class="theme-option" data-theme="lavender">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #a8edea;"></div>
                            <div class="theme-color" style="background: #fed6e3;"></div>
                            <div class="theme-color" style="background: #d299c2;"></div>
                        </div>
                        <span>Lavender</span>
                    </div>
                    <div class="theme-option" data-theme="coral">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #ff7e5f;"></div>
                            <div class="theme-color" style="background: #feb47b;"></div>
                            <div class="theme-color" style="background: #ff6b6b;"></div>
                        </div>
                        <span>Coral</span>
                    </div>
                    <div class="theme-option" data-theme="emerald">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #11998e;"></div>
                            <div class="theme-color" style="background: #38ef7d;"></div>
                            <div class="theme-color" style="background: #56ab2f;"></div>
                        </div>
                        <span>Emerald</span>
                    </div>
                    <div class="theme-option" data-theme="cosmic">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #667eea;"></div>
                            <div class="theme-color" style="background: #764ba2;"></div>
                            <div class="theme-color" style="background: #f093fb;"></div>
                        </div>
                        <span>Cosmic</span>
                    </div>
                    <div class="theme-option" data-theme="tropical">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #f093fb;"></div>
                            <div class="theme-color" style="background: #f5576c;"></div>
                            <div class="theme-color" style="background: #4facfe;"></div>
                        </div>
                        <span>Tropical</span>
                    </div>
                    <div class="theme-option" data-theme="autumn">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #ff9a9e;"></div>
                            <div class="theme-color" style="background: #fecfef;"></div>
                            <div class="theme-color" style="background: #fecfef;"></div>
                        </div>
                        <span>Autumn</span>
                    </div>
                    <div class="theme-option" data-theme="arctic">
                        <div class="theme-preview">
                            <div class="theme-color" style="background: #74b9ff;"></div>
                            <div class="theme-color" style="background: #0984e3;"></div>
                            <div class="theme-color" style="background: #a29bfe;"></div>
                        </div>
                        <span>Arctic</span>
                    </div>
                </div>
            </div>
            
            <hr style="margin: 20px 0; border: 1px solid #eee;">
            
            <div class="color-input-group">
                <label>Workflow Container:</label>
                <input type="color" id="workflowBgColor" value="#fa709a">
            </div>
            <div class="color-input-group">
                <label>Central Engine:</label>
                <input type="color" id="centralEngineBgColor" value="#667eea">
            </div>
            <div class="color-input-group">
                <label>Smart Tasks:</label>
                <input type="color" id="smartTasksBgColor" value="#e74c3c">
            </div>
            <div class="color-input-group">
                <label>Network Nodes:</label>
                <input type="color" id="networkNodesBgColor" value="#ffffff">
            </div>
            <div class="color-input-group">
                <label>Text Labels:</label>
                <input type="color" id="textLabelsBgColor" value="#ecf0f1">
            </div>
            <div class="color-input-group">
                <label>Page Background:</label>
                <input type="color" id="pageBgColor" value="#667eea">
            </div>
            <div class="modal-buttons">
                <button id="applyBgColors">Apply</button>
                <button id="resetBgColors">Reset</button>
                <button id="closeBgColorModal">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Icon Modal -->
    <div id="editIconModal" class="modal">
        <div class="modal-content">
            <h3>Edit Icon</h3>
            <button class="modal-close" onclick="closeModal('editIconModal')">&times;</button>
            <div class="icon-library">
                <i class="fas fa-star" data-icon="fas fa-star"></i>
                <i class="fas fa-heart" data-icon="fas fa-heart"></i>
                <i class="fas fa-flag" data-icon="fas fa-flag"></i>
                <i class="fas fa-bell" data-icon="fas fa-bell"></i>
                <i class="fas fa-bookmark" data-icon="fas fa-bookmark"></i>
                <i class="fas fa-gem" data-icon="fas fa-gem"></i>
                <i class="fas fa-cog" data-icon="fas fa-cog"></i>
                <i class="fas fa-lightbulb" data-icon="fas fa-lightbulb"></i>
                <i class="fas fa-rocket" data-icon="fas fa-rocket"></i>
                <i class="fas fa-shield-alt" data-icon="fas fa-shield-alt"></i>
                <i class="fas fa-clock" data-icon="fas fa-clock"></i>
                <i class="fas fa-map-marker-alt" data-icon="fas fa-map-marker-alt"></i>
            </div>
            <div class="modal-buttons">
                <button id="updateIcon">Update</button>
                <button id="cancelEditIcon">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Edit Text Box Modal -->
    <div id="editTextBoxModal" class="modal">
        <div class="modal-content">
            <h3>Edit Text Box</h3>
            <button class="modal-close" onclick="closeModal('editTextBoxModal')">&times;</button>
            <textarea id="editTextBoxContent" placeholder="Enter text content" rows="4" style="width: 100%; min-height: 80px; resize: vertical; font-family: inherit; font-size: inherit; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px;"></textarea>
            <select id="editTextBoxFontSize">
                <option value="12px">12px</option>
                <option value="14px">14px</option>
                <option value="16px">16px</option>
                <option value="18px">18px</option>
                <option value="20px">20px</option>
                <option value="24px">24px</option>
            </select>
            <select id="editTextBoxFontFamily">
                <option value="Arial, sans-serif">Arial</option>
                <option value="Times New Roman, serif">Times New Roman</option>
                <option value="Courier New, monospace">Courier New</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="Verdana, sans-serif">Verdana</option>
            </select>
            <input type="color" id="editTextBoxFontColor" value="#2c3e50">
            <div class="modal-buttons">
                <button id="updateTextBox">Update</button>
                <button id="cancelEditTextBox">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Edit Label Box Modal -->
    <div id="editLabelBoxModal" class="modal">
        <div class="modal-content">
            <h3>Edit Label Box</h3>
            <button class="modal-close" onclick="closeModal('editLabelBoxModal')">&times;</button>
            <input type="text" id="editLabelBoxName" placeholder="Enter label name">
            <select id="editLabelBoxFontSize">
                <option value="10px">10px</option>
                <option value="12px">12px</option>
                <option value="14px">14px</option>
                <option value="16px">16px</option>
                <option value="18px">18px</option>
                <option value="20px">20px</option>
                <option value="24px">24px</option>
            </select>
            <div class="shape-selector">
                <div class="shape-option" data-shape="circle">●</div>
                <div class="shape-option" data-shape="square">■</div>
                <div class="shape-option" data-shape="rectangle">▬</div>
                <div class="shape-option" data-shape="rounded-rectangle">▢</div>
                <div class="shape-option" data-shape="diamond">◆</div>
                <div class="shape-option" data-shape="hexagon">⬡</div>
                <div class="shape-option" data-shape="triangle">▲</div>
            </div>
            <div class="icon-library">
                <i class="fas fa-star" data-icon="fas fa-star"></i>
                <i class="fas fa-heart" data-icon="fas fa-heart"></i>
                <i class="fas fa-flag" data-icon="fas fa-flag"></i>
                <i class="fas fa-bell" data-icon="fas fa-bell"></i>
                <i class="fas fa-tasks" data-icon="fas fa-tasks"></i>
            </div>
            <div class="color-selector">
                <div class="color-option" data-color="#667eea" style="background: #667eea;"></div>
                <div class="color-option" data-color="#e74c3c" style="background: #e74c3c;"></div>
                <div class="color-option" data-color="#2ecc71" style="background: #2ecc71;"></div>
                <div class="color-option" data-color="#f39c12" style="background: #f39c12;"></div>
                <div class="color-option" data-color="#9b59b6" style="background: #9b59b6;"></div>
                <div class="color-option" data-color="#1abc9c" style="background: #1abc9c;"></div>
            </div>
            <div class="modal-buttons">
                <button id="updateLabelBox">Update</button>
                <button id="cancelEditLabelBox">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Line Creation Modal -->
    <div id="lineModal" class="modal">
        <div class="modal-content">
            <h3>Create New Line</h3>
            <button class="modal-close" onclick="closeModal('lineModal')">&times;</button>
            
            <div class="line-type-selector">
                <h4>Line Type</h4>
                <div class="line-types">
                    <div class="line-type-option" data-type="straight">
                        <div class="line-preview straight-line"></div>
                        <span>Straight</span>
                    </div>
                    <div class="line-type-option" data-type="curved">
                        <div class="line-preview curved-line"></div>
                        <span>Curved</span>
                    </div>
                    <div class="line-type-option" data-type="arrow">
                        <div class="line-preview arrow-line"></div>
                        <span>Arrow</span>
                    </div>
                    <div class="line-type-option" data-type="dashed">
                        <div class="line-preview dashed-line"></div>
                        <span>Dashed</span>
                    </div>
                    <div class="line-type-option" data-type="dotted">
                        <div class="line-preview dotted-line"></div>
                        <span>Dotted</span>
                    </div>
                    <div class="line-type-option" data-type="zigzag">
                        <div class="line-preview zigzag-line"></div>
                        <span>Zigzag</span>
                    </div>
                    <div class="line-type-option" data-type="circle">
                        <div class="line-preview circle-line"></div>
                        <span>Circle</span>
                    </div>
                    <div class="line-type-option" data-type="square">
                        <div class="line-preview square-line"></div>
                        <span>Square</span>
                    </div>
                </div>
            </div>
            
            <div class="line-customization">
                <div class="customization-group">
                    <label>Line Color:</label>
                    <input type="color" id="lineColor" value="#2c3e50">
                </div>
                <div class="customization-group">
                    <label>Line Thickness:</label>
                    <select id="lineThickness">
                        <option value="1">1px</option>
                        <option value="2" selected>2px</option>
                        <option value="3">3px</option>
                        <option value="4">4px</option>
                        <option value="5">5px</option>
                        <option value="6">6px</option>
                    </select>
                </div>
            </div>
            
            <div class="modal-buttons">
                <button id="createLine">Create Line</button>
                <button id="cancelLine">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Edit Line Modal -->
    <div id="editLineModal" class="modal">
        <div class="modal-content">
            <h3>Edit Line</h3>
            <button class="modal-close" onclick="closeModal('editLineModal')">&times;</button>
            
            <div class="line-type-selector">
                <h4>Line Type</h4>
                <div class="line-types">
                    <div class="line-type-option" data-type="straight">
                        <div class="line-preview straight-line"></div>
                        <span>Straight</span>
                    </div>
                    <div class="line-type-option" data-type="curved">
                        <div class="line-preview curved-line"></div>
                        <span>Curved</span>
                    </div>
                    <div class="line-type-option" data-type="arrow">
                        <div class="line-preview arrow-line"></div>
                        <span>Arrow</span>
                    </div>
                    <div class="line-type-option" data-type="dashed">
                        <div class="line-preview dashed-line"></div>
                        <span>Dashed</span>
                    </div>
                    <div class="line-type-option" data-type="dotted">
                        <div class="line-preview dotted-line"></div>
                        <span>Dotted</span>
                    </div>
                    <div class="line-type-option" data-type="zigzag">
                        <div class="line-preview zigzag-line"></div>
                        <span>Zigzag</span>
                    </div>
                </div>
            </div>
            
            <div class="line-customization">
                <div class="customization-group">
                    <label>Line Color:</label>
                    <input type="color" id="editLineColor" value="#2c3e50">
                </div>
                <div class="customization-group">
                    <label>Line Thickness:</label>
                    <select id="editLineThickness">
                        <option value="1">1px</option>
                        <option value="2">2px</option>
                        <option value="3">3px</option>
                        <option value="4">4px</option>
                        <option value="5">5px</option>
                        <option value="6">6px</option>
                    </select>
                </div>
            </div>
            
            <div class="modal-buttons">
                <button id="updateLine">Update Line</button>
                <button id="cancelEditLine">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div id="contextMenu" class="context-menu">
        <div class="context-menu-item" data-action="addIcon">Add New Icon</div>
        <div class="context-menu-item" data-action="addLabelBox">Add New Label Box</div>
        <div class="context-menu-item" data-action="addText">Add New Text</div>
        <div class="context-menu-item" data-action="addLine">Add New Line</div>
        <div class="context-menu-item" data-action="editBgColors">Edit Background Colors</div>
        <div class="context-menu-item" data-action="toggleMenu">Show/Hide Menu</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="paste">Paste Element</div>
    </div>

    <!-- Element Context Menu -->
    <div id="elementContextMenu" class="context-menu">
        <div class="context-menu-item" data-action="edit">Edit</div>
        <div class="context-menu-item" data-action="copy">Copy Element</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="sendToFront">Send to Front</div>
        <div class="context-menu-item" data-action="sendToBack">Send to Back</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="delete">Delete</div>
    </div>

    <!-- Title Context Menu -->
    <div id="titleContextMenu" class="context-menu">
        <div class="context-menu-item" data-action="editTitle">Edit Title</div>
        <div class="context-menu-item" data-action="resizeTitle">Resize Title</div>
        <div class="context-menu-item" data-action="resetTitlePosition">Reset Position</div>
    </div>

    <script>
        // Global variables
        let isDragging = false;
        let dragElement = null;
        let dragOffset = { x: 0, y: 0 };
        let selectedIcon = null;
        let selectedShape = null;
        let selectedLabelIcon = null;
        let selectedColor = '#667eea';
        let copiedElementData = null; // Store copied element data
        let currentTargetElement = null; // Store current target element for context menu
        
        // Line system variables
        let isCreatingLine = false;
        let lineStartPoint = null;
        let currentLine = null;
        let selectedLineType = 'straight';
        let selectedLineColor = '#2c3e50';
        let selectedLineThickness = 2;
        let selectedLine = null;

        // Modal utility functions
        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'none';
            }
        }

        function initModalClickOutside() {
            // Close modal when clicking outside the modal content
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('modal')) {
                    e.target.style.display = 'none';
                }
            });
        }

        function initKeyboardShortcuts() {
            // Handle keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                // Delete key (DEL or Backspace)
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    // Only delete if no modal is open and no input is focused
                    const activeElement = document.activeElement;
                    const isInputFocused = activeElement && (
                        activeElement.tagName === 'INPUT' || 
                        activeElement.tagName === 'TEXTAREA' || 
                        activeElement.contentEditable === 'true'
                    );
                    
                    if (!isInputFocused && selectedLine) {
                        e.preventDefault();
                        deleteSelectedLine();
                    }
                }
                
                // Escape key to deselect
                if (e.key === 'Escape') {
                    if (selectedLine) {
                        selectedLine.classList.remove('selected');
                        selectedLine = null;
                    }
                }
            });
            
            // Click outside to deselect lines
            document.addEventListener('click', function(e) {
                // Check if click is on a line or line control
                const clickedLine = e.target.closest('.workflow-line');
                const clickedControl = e.target.closest('.line-endpoint');
                
                // If clicking on background or non-line elements, deselect
                if (!clickedLine && !clickedControl && selectedLine) {
                    selectedLine.classList.remove('selected');
                    selectedLine = null;
                }
            });
        }

        // Theme color definitions
        const colorThemes = {
            default: {
                workflowBg: '#fa709a',
                engineBg: '#667eea',
                smartTasksBg: '#e74c3c',
                nodesBg: '#ffffff',
                labelsBg: '#ecf0f1',
                pageBg: '#667eea'
            },
            ocean: {
                workflowBg: '#667eea',
                engineBg: '#764ba2',
                smartTasksBg: '#f093fb',
                nodesBg: '#ffffff',
                labelsBg: '#e3f2fd',
                pageBg: '#667eea'
            },
            sunset: {
                workflowBg: '#ff9a9e',
                engineBg: '#fecfef',
                smartTasksBg: '#fecfef',
                nodesBg: '#ffffff',
                labelsBg: '#fff5f5',
                pageBg: '#ff9a9e'
            },
            forest: {
                workflowBg: '#56ab2f',
                engineBg: '#a8e6cf',
                smartTasksBg: '#ffd3a5',
                nodesBg: '#ffffff',
                labelsBg: '#f0fff4',
                pageBg: '#56ab2f'
            },
            fire: {
                workflowBg: '#ff416c',
                engineBg: '#ff4b2b',
                smartTasksBg: '#ff6b6b',
                nodesBg: '#ffffff',
                labelsBg: '#fff5f5',
                pageBg: '#ff416c'
            },
            purple: {
                workflowBg: '#667eea',
                engineBg: '#764ba2',
                smartTasksBg: '#f093fb',
                nodesBg: '#ffffff',
                labelsBg: '#f3e5f5',
                pageBg: '#667eea'
            },
            midnight: {
                workflowBg: '#2c3e50',
                engineBg: '#34495e',
                smartTasksBg: '#3498db',
                nodesBg: '#ffffff',
                labelsBg: '#ecf0f1',
                pageBg: '#2c3e50'
            },
            aurora: {
                workflowBg: '#00c9ff',
                engineBg: '#92fe9d',
                smartTasksBg: '#ff9a9e',
                nodesBg: '#ffffff',
                labelsBg: '#e3f2fd',
                pageBg: '#00c9ff'
            },
            golden: {
                workflowBg: '#f7971e',
                engineBg: '#ffd200',
                smartTasksBg: '#ff6b6b',
                nodesBg: '#ffffff',
                labelsBg: '#fff8e1',
                pageBg: '#f7971e'
            },
            lavender: {
                workflowBg: '#a8edea',
                engineBg: '#fed6e3',
                smartTasksBg: '#d299c2',
                nodesBg: '#ffffff',
                labelsBg: '#f3e5f5',
                pageBg: '#a8edea'
            },
            coral: {
                workflowBg: '#ff7e5f',
                engineBg: '#feb47b',
                smartTasksBg: '#ff6b6b',
                nodesBg: '#ffffff',
                labelsBg: '#fff5f5',
                pageBg: '#ff7e5f'
            },
            emerald: {
                workflowBg: '#11998e',
                engineBg: '#38ef7d',
                smartTasksBg: '#56ab2f',
                nodesBg: '#ffffff',
                labelsBg: '#f0fff4',
                pageBg: '#11998e'
            },
            cosmic: {
                workflowBg: '#667eea',
                engineBg: '#764ba2',
                smartTasksBg: '#f093fb',
                nodesBg: '#ffffff',
                labelsBg: '#f3e5f5',
                pageBg: '#667eea'
            },
            tropical: {
                workflowBg: '#f093fb',
                engineBg: '#f5576c',
                smartTasksBg: '#4facfe',
                nodesBg: '#ffffff',
                labelsBg: '#fff5f5',
                pageBg: '#f093fb'
            },
            autumn: {
                workflowBg: '#ff9a9e',
                engineBg: '#fecfef',
                smartTasksBg: '#fecfef',
                nodesBg: '#ffffff',
                labelsBg: '#fff5f5',
                pageBg: '#ff9a9e'
            },
            arctic: {
                workflowBg: '#74b9ff',
                engineBg: '#0984e3',
                smartTasksBg: '#a29bfe',
                nodesBg: '#ffffff',
                labelsBg: '#e3f2fd',
                pageBg: '#74b9ff'
            }
        };

        function applyThemeColors(themeName) {
            const theme = colorThemes[themeName];
            if (!theme) return;

            // Update color inputs
            document.getElementById('workflowBgColor').value = theme.workflowBg;
            document.getElementById('centralEngineBgColor').value = theme.engineBg;
            document.getElementById('smartTasksBgColor').value = theme.smartTasksBg;
            document.getElementById('networkNodesBgColor').value = theme.nodesBg;
            document.getElementById('textLabelsBgColor').value = theme.labelsBg;
            document.getElementById('pageBgColor').value = theme.pageBg;

            // Apply colors immediately
            applyBackgroundColors();
        }

        function showBgColorModal() {
            const modal = document.getElementById('bgColorModal');
            modal.style.display = 'block';
        }

        function applyBackgroundColors() {
            const workflowBg = document.getElementById('workflowBgColor').value;
            const engineBg = document.getElementById('centralEngineBgColor').value;
            const smartTasksBg = document.getElementById('smartTasksBgColor').value;
            const nodesBg = document.getElementById('networkNodesBgColor').value;
            const labelsBg = document.getElementById('textLabelsBgColor').value;
            const pageBg = document.getElementById('pageBgColor').value;

            // Apply colors to elements
            document.querySelector('.workflow-container').style.background = `linear-gradient(135deg, ${workflowBg} 0%, ${engineBg} 100%)`;
            document.querySelector('.central-engine').style.background = engineBg;
            document.querySelector('.smart-tasks').style.background = smartTasksBg;
            document.querySelectorAll('.network-node').forEach(node => {
                node.style.background = nodesBg;
            });
            document.querySelectorAll('.node-label, .text-box').forEach(label => {
                label.style.background = labelsBg;
            });
            document.body.style.background = `linear-gradient(135deg, ${pageBg} 0%, ${engineBg} 100%)`;

            // Save colors to localStorage
            const colors = {
                workflowBg: workflowBg,
                engineBg: engineBg,
                smartTasksBg: smartTasksBg,
                nodesBg: nodesBg,
                labelsBg: labelsBg,
                pageBg: pageBg
            };
            localStorage.setItem('workflowColors', JSON.stringify(colors));
        }

        function resetBackgroundColors() {
            // Reset to default colors
            document.getElementById('workflowBgColor').value = '#fa709a';
            document.getElementById('centralEngineBgColor').value = '#667eea';
            document.getElementById('smartTasksBgColor').value = '#e74c3c';
            document.getElementById('networkNodesBgColor').value = '#ffffff';
            document.getElementById('textLabelsBgColor').value = '#ecf0f1';
            document.getElementById('pageBgColor').value = '#667eea';
            
            applyBackgroundColors();
        }

        // Line System Functions
        function showLineModal() {
            const modal = document.getElementById('lineModal');
            modal.style.display = 'block';
        }

        function createNewLine(type, color, thickness) {
            const container = document.querySelector('.workflow-container');
            
            // Create line element
            const newLine = document.createElement('div');
            newLine.className = 'workflow-line';
            newLine.dataset.lineType = type;
            newLine.dataset.lineColor = color;
            newLine.dataset.lineThickness = thickness;
            if (type === 'curved') {
                newLine.dataset.curveHeight = '20'; // Default curve height
            }
            
            // Set initial position (center of container)
            const containerRect = container.getBoundingClientRect();
            const centerX = containerRect.width / 2;
            const centerY = containerRect.height / 2;
            
            // Set data attribute for CSS targeting
            newLine.dataset.lineType = type;
            
            if (type === 'circle' || type === 'square') {
                // For shapes, use exact content size - no extra space
                newLine.style.left = (centerX - 75) + 'px';
                newLine.style.top = (centerY - 75) + 'px';
                newLine.style.width = '150px';
                newLine.style.height = '150px';
                newLine.style.minWidth = '150px';
                newLine.style.minHeight = '150px';
            } else {
                // For lines, use much smaller initial size to avoid blocking edges
                newLine.style.left = (centerX - 50) + 'px';
                newLine.style.top = (centerY - 10) + 'px';
                newLine.style.width = '100px';
                newLine.style.height = '20px';
            }
            
            // Apply line styling based on type
            applyLineStyling(newLine, type, color, thickness);
            
            // Add endpoints (positioned differently for shapes vs lines)
            const startEndpoint = document.createElement('div');
            startEndpoint.className = 'line-endpoint';
            const endEndpoint = document.createElement('div');
            endEndpoint.className = 'line-endpoint';
            
            if (type === 'circle' || type === 'square') {
                // For shapes, position endpoints at the edges for resizing
                startEndpoint.style.left = '0px';
                startEndpoint.style.top = '75px';
                startEndpoint.dataset.endpoint = 'start';
                
                endEndpoint.style.right = '0px';
                endEndpoint.style.top = '75px';
                endEndpoint.dataset.endpoint = 'end';
            } else {
                // For lines, position endpoints at the line ends
                startEndpoint.style.left = '50px';
                startEndpoint.style.top = '50px';
                startEndpoint.dataset.endpoint = 'start';
                
                endEndpoint.style.right = '50px';
                endEndpoint.style.top = '50px';
                endEndpoint.dataset.endpoint = 'end';
            }
            
            newLine.appendChild(startEndpoint);
            newLine.appendChild(endEndpoint);
            
            // Add curve control points for curved lines
            if (type === 'curved') {
                // Main curve control (center) - positioned within container bounds
                const curveControl = document.createElement('div');
                curveControl.className = 'line-endpoint curve-control';
                curveControl.style.left = '50%';
                curveControl.style.top = '30px'; // Position within smaller container
                curveControl.style.transform = 'translateX(-50%)';
                curveControl.dataset.endpoint = 'curve';
                curveControl.title = 'Drag to adjust curve height';
                
                // Direction control (for curve direction) - positioned within container bounds
                const directionControl = document.createElement('div');
                directionControl.className = 'line-endpoint direction-control';
                directionControl.style.left = '50%';
                directionControl.style.top = '70px'; // Position within smaller container
                directionControl.style.transform = 'translateX(-50%)';
                directionControl.dataset.endpoint = 'direction';
                directionControl.title = 'Click to flip curve direction';
                
                newLine.appendChild(curveControl);
                newLine.appendChild(directionControl);
                
                curveControl.addEventListener('mousedown', startCurveControlDrag);
                directionControl.addEventListener('mousedown', startDirectionControlDrag);
            }
            
            // Add rotation control for all line types
            const rotationControl = document.createElement('div');
            rotationControl.className = 'line-endpoint rotation-control';
            rotationControl.style.left = '50%';
            rotationControl.style.top = '50%';
            rotationControl.style.transform = 'translate(-50%, -50%)';
            rotationControl.dataset.endpoint = 'rotation';
            rotationControl.title = 'Drag to rotate line';
            
            newLine.appendChild(rotationControl);
            rotationControl.addEventListener('mousedown', startRotationDrag);
            
            container.appendChild(newLine);
            
            // Make it draggable, editable, and resizable
            newLine.addEventListener('mousedown', startLineDrag);
            newLine.addEventListener('touchstart', startLineDrag);
            newLine.addEventListener('dblclick', startLineEditing);
            newLine.addEventListener('click', function(e) {
                e.stopPropagation();
                selectLine(newLine);
            });
            startEndpoint.addEventListener('mousedown', startEndpointDrag);
            endEndpoint.addEventListener('mousedown', startEndpointDrag);
            makeResizable(newLine);
            
            saveLayout();
            return newLine;
        }

        function applyLineStyling(lineElement, type, color, thickness) {
            lineElement.style.backgroundColor = 'transparent';
            lineElement.style.border = 'none';
            
            // Remove existing line content if it exists
            const existingContent = lineElement.querySelector('.line-content');
            if (existingContent) {
                existingContent.remove();
            }
            
            // Create line content container
            const lineContent = document.createElement('div');
            lineContent.className = 'line-content';
            lineElement.appendChild(lineContent);
            
            // Remove existing SVG if it exists
            const existingSvg = lineElement.querySelector('svg');
            if (existingSvg) {
                existingSvg.remove();
            }
            
            switch (type) {
                case 'straight':
                    lineContent.style.background = color;
                    lineContent.style.height = thickness + 'px';
                    lineContent.style.width = '100%';
                    break;
                case 'curved':
                    // Create curved line using SVG in the line content
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.style.position = 'absolute';
                    svg.style.top = '0';
                    svg.style.left = '0';
                    svg.style.width = '100%';
                    svg.style.height = '100%';
                    svg.style.pointerEvents = 'none';
                    
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const curveHeight = parseInt(lineElement.dataset.curveHeight) || 20;
                    const curveDirection = lineElement.dataset.curveDirection || 'up';
                    const startY = 10;
                    let controlY;
                    
                    if (curveDirection === 'up') {
                        controlY = startY - curveHeight;
                    } else {
                        controlY = startY + curveHeight;
                    }
                    
                    // Use dynamic width based on container
                    path.setAttribute('d', `M 0,${startY} Q 50%,${controlY} 100%,${startY}`);
                    path.setAttribute('stroke', color);
                    path.setAttribute('stroke-width', thickness);
                    path.setAttribute('fill', 'none');
                    
                    svg.appendChild(path);
                    lineContent.appendChild(svg);
                    break;
                case 'arrow':
                    lineContent.style.background = `linear-gradient(to right, ${color} 0%, ${color} 80%, transparent 80%)`;
                    lineContent.style.height = thickness + 'px';
                    lineContent.style.width = '100%';
                    lineContent.style.position = 'relative';
                    // Add or update arrow head
                    let arrowHead = lineContent.querySelector('.arrow-head');
                    if (!arrowHead) {
                        arrowHead = document.createElement('div');
                        arrowHead.className = 'arrow-head';
                        lineContent.appendChild(arrowHead);
                    }
                    arrowHead.style.cssText = `
                        position: absolute;
                        right: 0;
                        top: -3px;
                        width: 0;
                        height: 0;
                        border-left: 6px solid ${color};
                        border-top: 4px solid transparent;
                        border-bottom: 4px solid transparent;
                    `;
                    break;
                case 'dashed':
                    lineContent.style.background = `repeating-linear-gradient(to right, ${color} 0px, ${color} 4px, transparent 4px, transparent 8px)`;
                    lineContent.style.height = thickness + 'px';
                    lineContent.style.width = '100%';
                    break;
                case 'dotted':
                    lineContent.style.background = `repeating-linear-gradient(to right, ${color} 0px, ${color} 2px, transparent 2px, transparent 4px)`;
                    lineContent.style.height = thickness + 'px';
                    lineContent.style.width = '100%';
                    break;
                case 'zigzag':
                    lineContent.style.background = `linear-gradient(45deg, ${color} 25%, transparent 25%), 
                                                  linear-gradient(-45deg, ${color} 25%, transparent 25%), 
                                                  linear-gradient(45deg, transparent 75%, ${color} 75%), 
                                                  linear-gradient(-45deg, transparent 75%, ${color} 75%)`;
                    lineContent.style.backgroundSize = '8px 8px';
                    lineContent.style.backgroundPosition = '0 0, 0 4px, 4px -4px, -4px 0px';
                    lineContent.style.height = thickness + 'px';
                    lineContent.style.width = '100%';
                    break;
                case 'circle':
                    lineContent.style.background = 'none';
                    lineContent.style.border = `${thickness}px solid ${color}`;
                    lineContent.style.borderRadius = '50%';
                    lineContent.style.width = '100%';
                    lineContent.style.height = '100%';
                    break;
                case 'square':
                    lineContent.style.background = 'none';
                    lineContent.style.border = `${thickness}px solid ${color}`;
                    lineContent.style.borderRadius = '0';
                    lineContent.style.width = '100%';
                    lineContent.style.height = '100%';
                    break;
            }
        }

        function startLineDrag(e) {
            // Don't start drag if clicking on a resize handle
            if (e.target.classList.contains('resize-handle')) {
                return;
            }
            
            e.preventDefault();
            e.stopPropagation();
            
            isDragging = true;
            dragElement = e.currentTarget;
            
            const rect = dragElement.getBoundingClientRect();
            const containerRect = document.querySelector('.workflow-container').getBoundingClientRect();
            
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            dragElement.classList.add('dragging');
            
            document.addEventListener('mousemove', onLineDrag);
            document.addEventListener('mouseup', stopLineDrag);
        }

        function onLineDrag(e) {
            if (!isDragging || !dragElement) return;
            
            e.preventDefault();
            const containerRect = document.querySelector('.workflow-container').getBoundingClientRect();
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            
            let newX = clientX - containerRect.left - dragOffset.x;
            let newY = clientY - containerRect.top - dragOffset.y;
            
            // Allow free positioning - no boundary restrictions
            dragElement.style.left = newX + 'px';
            dragElement.style.top = newY + 'px';
            
            // Check if element is outside container bounds and bring to front
            const elementRect = dragElement.getBoundingClientRect();
            const isOutside = newX < 0 || newY < 0 || 
                             newX + elementRect.width > containerRect.width || 
                             newY + elementRect.height > containerRect.height;
            
            if (isOutside) {
                // Bring element to front when outside container
                dragElement.style.zIndex = '2000';
            }
        }

        function stopLineDrag() {
            if (isDragging && dragElement) {
                dragElement.classList.remove('dragging');
                isDragging = false;
                dragElement = null;
                saveLayout();
            }
            
            document.removeEventListener('mousemove', onLineDrag);
            document.removeEventListener('mouseup', stopLineDrag);
        }

        function startEndpointDrag(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const endpoint = e.currentTarget;
            const line = endpoint.parentElement;
            const isStart = endpoint.dataset.endpoint === 'start';
            
            const rect = line.getBoundingClientRect();
            const containerRect = document.querySelector('.workflow-container').getBoundingClientRect();
            
            let startX = rect.left - containerRect.left;
            let startY = rect.top - containerRect.top;
            let startWidth = rect.width;
            let startLeft = parseFloat(line.style.left) || 0;
            
            function onEndpointMove(e) {
                const clientX = e.clientX;
                const clientY = e.clientY;
                
                const newX = clientX - containerRect.left;
                const newY = clientY - containerRect.top;
                
                const lineType = line.dataset.lineType;
                
                if (lineType === 'circle' || lineType === 'square') {
                    // For shapes, resize both width and height proportionally
                    const deltaX = newX - startX;
                    const deltaY = newY - startY;
                    const delta = Math.max(Math.abs(deltaX), Math.abs(deltaY));
                    
                    const newSize = Math.max(50, startWidth + delta);
                    
                    if (isStart) {
                        // Dragging start point - adjust size and position
                        const newLeft = startLeft - delta;
                        const newTop = startY - delta;
                        
                        line.style.left = newLeft + 'px';
                        line.style.top = newTop + 'px';
                        line.style.width = newSize + 'px';
                        line.style.height = newSize + 'px';
                        
                        // Update line content size - no padding needed
                        const lineContent = line.querySelector('.line-content');
                        if (lineContent) {
                            lineContent.style.width = newSize + 'px';
                            lineContent.style.height = newSize + 'px';
                        }
                    } else {
                        // Dragging end point - adjust size only
                        line.style.width = newSize + 'px';
                        line.style.height = newSize + 'px';
                        
                        // Update line content size - no padding needed
                        const lineContent = line.querySelector('.line-content');
                        if (lineContent) {
                            lineContent.style.width = newSize + 'px';
                            lineContent.style.height = newSize + 'px';
                        }
                    }
                } else {
                    // For lines, use original logic
                    if (isStart) {
                        // Dragging start point - adjust width and position
                        const newWidth = startWidth + (startX - newX);
                        const newLeft = startLeft + (startX - newX);
                        
                        if (newWidth > 20) { // Minimum width
                            line.style.left = newLeft + 'px';
                            line.style.width = newWidth + 'px';
                        }
                        
                        // Allow vertical movement for all line types
                        const newTop = newY - (lineType === 'curved' ? 10 : 0);
                        line.style.top = newTop + 'px';
                    } else {
                        // Dragging end point - adjust width only
                        const newWidth = newX - startX;
                        
                        if (newWidth > 20) { // Minimum width
                            line.style.width = newWidth + 'px';
                        }
                        
                        // Allow vertical movement for all line types
                        const newTop = newY - (lineType === 'curved' ? 10 : 0);
                        line.style.top = newTop + 'px';
                    }
                }
                
                // Ensure container is large enough for the line
                ensureLineVisibility(line);
            }
            
            function onEndpointUp() {
                document.removeEventListener('mousemove', onEndpointMove);
                document.removeEventListener('mouseup', onEndpointUp);
                
                // Update curved line if needed
                if (line.dataset.lineType === 'curved') {
                    updateCurvedLine(line);
                }
                
                // Final visibility check
                ensureLineVisibility(line);
                saveLayout();
            }
            
            document.addEventListener('mousemove', onEndpointMove);
            document.addEventListener('mouseup', onEndpointUp);
        }

        function updateCurvedLine(lineElement) {
            const existingSvg = lineElement.querySelector('svg');
            if (existingSvg) {
                existingSvg.remove();
            }
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.style.position = 'absolute';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.pointerEvents = 'none';
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const width = lineElement.offsetWidth;
            const curveHeight = parseInt(lineElement.dataset.curveHeight) || 20;
            const curveDirection = lineElement.dataset.curveDirection || 'up';
            const color = lineElement.dataset.lineColor || '#2c3e50';
            const thickness = lineElement.dataset.lineThickness || 2;
            
            // Create curve with adjustable height and direction
            const startY = 10; // Center line
            let controlY;
            
            if (curveDirection === 'up') {
                controlY = startY - curveHeight; // Curve goes up
            } else {
                controlY = startY + curveHeight; // Curve goes down
            }
            
            path.setAttribute('d', `M 0,${startY} Q ${width/2},${controlY} ${width},${startY}`);
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', thickness);
            path.setAttribute('fill', 'none');
            
            svg.appendChild(path);
            lineElement.appendChild(svg);
        }

        function selectLine(lineElement) {
            // Remove selection from all lines
            document.querySelectorAll('.workflow-line').forEach(line => {
                line.classList.remove('selected');
            });
            
            // Select the clicked line
            lineElement.classList.add('selected');
            selectedLine = lineElement;
            
            // Ensure line remains visible
            ensureLineVisibility(lineElement);
        }

        function ensureLineVisibility(lineElement) {
            // Don't reset line size - let user resize freely
            // This function is now just a placeholder to maintain compatibility
        }

        function deleteSelectedLine() {
            if (selectedLine) {
                selectedLine.remove();
                selectedLine = null;
                saveLayout();
            }
        }

        function startCurveControlDrag(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const curveControl = e.currentTarget;
            const line = curveControl.parentElement;
            
            const rect = line.getBoundingClientRect();
            const containerRect = document.querySelector('.workflow-container').getBoundingClientRect();
            
            let startY = rect.top - containerRect.top;
            let curveHeight = parseInt(line.dataset.curveHeight) || 20;
            
            function onCurveMove(e) {
                const clientY = e.clientY;
                const newY = clientY - containerRect.top;
                
                // Calculate new curve height based on vertical movement
                const deltaY = newY - startY;
                const newCurveHeight = Math.max(5, Math.min(100, curveHeight - deltaY)); // Increased range
                
                // Update the line's curve height
                line.dataset.curveHeight = newCurveHeight;
                updateCurvedLine(line);
            }
            
            function onCurveUp() {
                document.removeEventListener('mousemove', onCurveMove);
                document.removeEventListener('mouseup', onCurveUp);
                saveLayout();
            }
            
            document.addEventListener('mousemove', onCurveMove);
            document.addEventListener('mouseup', onCurveUp);
        }

        function startDirectionControlDrag(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const directionControl = e.currentTarget;
            const line = directionControl.parentElement;
            
            // Toggle curve direction
            const currentDirection = line.dataset.curveDirection || 'up';
            const newDirection = currentDirection === 'up' ? 'down' : 'up';
            line.dataset.curveDirection = newDirection;
            
            // Update the curve
            updateCurvedLine(line);
            saveLayout();
        }

        function startRotationDrag(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const rotationControl = e.currentTarget;
            const line = rotationControl.parentElement;
            
            const rect = line.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Store original dimensions (the actual line dimensions, not container)
            const originalWidth = parseFloat(line.style.width) || 100;
            const originalHeight = parseFloat(line.style.height) || 20;
            
            function onRotationMove(e) {
                const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                const degrees = (angle * 180 / Math.PI);
                
                // Apply rotation to the line
                line.style.transform = `rotate(${degrees}deg)`;
                
                // Calculate new container dimensions to accommodate rotation
                const radians = Math.abs(degrees * Math.PI / 180);
                const newWidth = Math.abs(originalWidth * Math.cos(radians)) + Math.abs(originalHeight * Math.sin(radians));
                const newHeight = Math.abs(originalWidth * Math.sin(radians)) + Math.abs(originalHeight * Math.cos(radians));
                
                // Set container size to accommodate the rotated line with padding
                line.style.width = (newWidth + 60) + 'px';
                line.style.height = (newHeight + 60) + 'px';
            }
            
            function onRotationUp() {
                document.removeEventListener('mousemove', onRotationMove);
                document.removeEventListener('mouseup', onRotationUp);
                
                // Final visibility check
                ensureLineVisibility(line);
                saveLayout();
            }
            
            document.addEventListener('mousemove', onRotationMove);
            document.addEventListener('mouseup', onRotationUp);
        }

        function startLineEditing(lineElement) {
            showEditLineModal(lineElement);
        }

        function showEditLineModal(lineElement) {
            const modal = document.getElementById('editLineModal');
            const typeInput = lineElement.dataset.lineType;
            const colorInput = lineElement.dataset.lineColor;
            const thicknessInput = lineElement.dataset.lineThickness;
            
            // Set current values
            document.getElementById('editLineColor').value = colorInput;
            document.getElementById('editLineThickness').value = thicknessInput;
            
            // Select current line type
            document.querySelectorAll('#editLineModal .line-type-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.type === typeInput) {
                    option.classList.add('selected');
                }
            });
            
            modal.editingElement = lineElement;
            modal.style.display = 'block';
        }

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initDragAndDrop();
            initTextEditing();
            initResize();
            initContextMenu();
            initModals();
            initControls();
            initModalClickOutside();
            initKeyboardShortcuts();
            loadLayout();
            
            // Add resize handles to existing elements that don't have them
            setTimeout(() => {
                document.querySelectorAll('.central-engine, .smart-tasks').forEach(element => {
                    if (!element.classList.contains('resizable')) {
                        makeResizable(element);
                    }
                });
                
                // Ensure all lines are visible after loading
                document.querySelectorAll('.workflow-line').forEach(line => {
                    ensureLineVisibility(line);
                });
            }, 100);
        });

        // Drag and Drop Functionality
        function initDragAndDrop() {
            const draggableElements = document.querySelectorAll('.network-node, .central-engine, .smart-tasks, .node-label, .text-box, .custom-label-box, .workflow-line');
            
            draggableElements.forEach(element => {
                if (element.classList.contains('workflow-line')) {
                    // Lines have their own drag handling
                    element.addEventListener('mousedown', startLineDrag);
                    element.addEventListener('touchstart', startLineDrag);
                } else {
                    element.addEventListener('mousedown', startDrag);
                    element.addEventListener('touchstart', startDrag);
                }
                
                // Add click event for selection (except for elements that already have it)
                if (!element.classList.contains('text-box') && !element.classList.contains('node-label')) {
                    element.addEventListener('click', function(e) {
                        e.stopPropagation();
                        // Remove selected class from all elements
                        document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                        // Add selected class to clicked element
                        element.classList.add('selected');
                    });
                }
            });
        }

        function startDrag(e) {
            e.preventDefault();
            e.stopPropagation();
            
            isDragging = true;
            dragElement = e.currentTarget;
            
            const rect = dragElement.getBoundingClientRect();
            const containerRect = document.querySelector('.workflow-container').getBoundingClientRect();
            
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            dragElement.classList.add('dragging');
            
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchmove', onDrag);
            document.addEventListener('touchend', stopDrag);
        }

        function onDrag(e) {
            if (!isDragging || !dragElement) return;
            
            e.preventDefault();
            const containerRect = document.querySelector('.workflow-container').getBoundingClientRect();
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            
            let newX = clientX - containerRect.left - dragOffset.x;
            let newY = clientY - containerRect.top - dragOffset.y;
            
            // Allow free positioning - no boundary restrictions
            dragElement.style.left = newX + 'px';
            dragElement.style.top = newY + 'px';
            
            // Check if element is outside container bounds and bring to front
            const elementRect = dragElement.getBoundingClientRect();
            const isOutside = newX < 0 || newY < 0 || 
                             newX + elementRect.width > containerRect.width || 
                             newY + elementRect.height > containerRect.height;
            
            if (isOutside) {
                // Bring element to front when outside container
                dragElement.style.zIndex = '2000';
            }
        }

        function stopDrag() {
            if (isDragging && dragElement) {
                dragElement.classList.remove('dragging');
                saveLayout();
            }
            
            isDragging = false;
            dragElement = null;
            
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchmove', onDrag);
            document.removeEventListener('touchend', stopDrag);
        }

        // Resize Functionality
        function initResize() {
            const resizableElements = document.querySelectorAll('.network-node, .central-engine, .smart-tasks, .text-box, .custom-label-box, .workflow-line');
            
            resizableElements.forEach(element => {
                makeResizable(element);
            });
        }
        
        function makeResizable(element) {
            element.classList.add('resizable');
            
            // Create resize handles
            const handles = ['nw', 'ne', 'sw', 'se'];
            handles.forEach(handle => {
                const resizeHandle = document.createElement('div');
                resizeHandle.className = `resize-handle ${handle}`;
                element.appendChild(resizeHandle);
                
                resizeHandle.addEventListener('mousedown', (e) => startResize(e, element, handle));
                resizeHandle.addEventListener('touchstart', (e) => startResize(e, element, handle));
                
                // Prevent resize handles from interfering with double-click
                resizeHandle.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                });
            });
        }
        
        let isResizing = false;
        let resizeElement = null;
        let resizeHandle = null;
        let startX, startY, startWidth, startHeight, startLeft, startTop;
        
        function startResize(e, element, handle) {
            e.preventDefault();
            e.stopPropagation();
            
            isResizing = true;
            resizeElement = element;
            resizeHandle = handle;
            
            const rect = element.getBoundingClientRect();
            startX = e.clientX || e.touches[0].clientX;
            startY = e.clientY || e.touches[0].clientY;
            startWidth = rect.width;
            startHeight = rect.height;
            startLeft = parseFloat(element.style.left) || 0;
            startTop = parseFloat(element.style.top) || 0;
            
            document.addEventListener('mousemove', onResize);
            document.addEventListener('mouseup', stopResize);
            document.addEventListener('touchmove', onResize);
            document.addEventListener('touchend', stopResize);
        }
        
        function onResize(e) {
            if (!isResizing || !resizeElement) return;
            
            e.preventDefault();
            const currentX = e.clientX || e.touches[0].clientX;
            const currentY = e.clientY || e.touches[0].clientY;
            
            const deltaX = currentX - startX;
            const deltaY = currentY - startY;
            
            let newWidth = startWidth;
            let newHeight = startHeight;
            let newLeft = startLeft;
            let newTop = startTop;
            
            // Check if element should maintain square/circular proportions
            const isCircular = resizeElement.classList.contains('network-node') || 
                              resizeElement.classList.contains('central-engine') ||
                              (resizeElement.dataset.lineType === 'circle');
            const isSquare = resizeElement.dataset.lineType === 'square';
            
            // Set minimum sizes based on element type
            const isLine = resizeElement.classList.contains('workflow-line');
            const minWidth = isLine ? 5 : 50;   // Lines can be very small
            const minHeight = isLine ? 2 : 30;  // Lines can be very small
            
            switch (resizeHandle) {
                case 'se':
                    newWidth = Math.max(minWidth, startWidth + deltaX);
                    newHeight = Math.max(minHeight, startHeight + deltaY);
                    break;
                case 'sw':
                    newWidth = Math.max(minWidth, startWidth - deltaX);
                    newHeight = Math.max(minHeight, startHeight + deltaY);
                    newLeft = startLeft + (startWidth - newWidth);
                    break;
                case 'ne':
                    newWidth = Math.max(minWidth, startWidth + deltaX);
                    newHeight = Math.max(minHeight, startHeight - deltaY);
                    newTop = startTop + (startHeight - newHeight);
                    break;
                case 'nw':
                    newWidth = Math.max(minWidth, startWidth - deltaX);
                    newHeight = Math.max(minHeight, startHeight - deltaY);
                    newLeft = startLeft + (startWidth - newWidth);
                    newTop = startTop + (startHeight - newHeight);
                    break;
            }
            
            // For circular elements, maintain square proportions
            if (isCircular) {
                const size = Math.max(newWidth, newHeight);
                newWidth = size;
                newHeight = size;
                
                // Adjust position to keep center
                if (resizeHandle === 'sw' || resizeHandle === 'nw') {
                    newLeft = startLeft + (startWidth - newWidth);
                }
                if (resizeHandle === 'ne' || resizeHandle === 'nw') {
                    newTop = startTop + (startHeight - newHeight);
                }
            }
            
            // For square shapes, maintain square proportions
            if (isSquare) {
                const size = Math.max(newWidth, newHeight);
                newWidth = size;
                newHeight = size;
                
                // Adjust position to keep center
                if (resizeHandle === 'sw' || resizeHandle === 'nw') {
                    newLeft = startLeft + (startWidth - newWidth);
                }
                if (resizeHandle === 'ne' || resizeHandle === 'nw') {
                    newTop = startTop + (startHeight - newHeight);
                }
            }
            
            resizeElement.style.width = newWidth + 'px';
            resizeElement.style.height = newHeight + 'px';
            resizeElement.style.left = newLeft + 'px';
            resizeElement.style.top = newTop + 'px';
            
            // Update icon sizes for network nodes and central engine
            if (resizeElement.classList.contains('network-node') || resizeElement.classList.contains('central-engine')) {
                const icon = resizeElement.querySelector('i');
                if (icon) {
                    // Scale icon size based on container size (roughly 30% of container size)
                    const iconSize = Math.max(12, Math.min(48, newWidth * 0.3));
                    icon.style.fontSize = iconSize + 'px';
                }
            }
            
            // Update text size for central engine
            if (resizeElement.classList.contains('central-engine')) {
                const textSize = Math.max(10, Math.min(24, newWidth * 0.08));
                resizeElement.style.fontSize = textSize + 'px';
            }
            
            // Update icon and text sizes for label boxes
            if (resizeElement.classList.contains('custom-label-box')) {
                const icon = resizeElement.querySelector('i');
                const text = resizeElement.querySelector('div');
                
                if (icon) {
                    // Scale icon size based on container size (roughly 25% of container height)
                    const iconSize = Math.max(12, Math.min(32, newHeight * 0.25));
                    icon.style.fontSize = iconSize + 'px';
                }
                
                if (text) {
                    // Scale text size based on container size (roughly 15% of container height)
                    const textSize = Math.max(8, Math.min(20, newHeight * 0.15));
                    text.style.fontSize = textSize + 'px';
                }
            }
            
            // For workflow lines, update the line content size
            if (resizeElement.classList.contains('workflow-line')) {
                const lineContent = resizeElement.querySelector('.line-content');
                if (lineContent) {
                    const lineType = resizeElement.dataset.lineType;
                    if (lineType === 'circle' || lineType === 'square') {
                        lineContent.style.width = newWidth + 'px';
                        lineContent.style.height = newHeight + 'px';
                    }
                }
            }
        }
        
        function stopResize() {
            if (isResizing && resizeElement) {
                saveLayout();
            }
            
            isResizing = false;
            resizeElement = null;
            resizeHandle = null;
            
            document.removeEventListener('mousemove', onResize);
            document.removeEventListener('mouseup', stopResize);
            document.removeEventListener('touchmove', onResize);
            document.removeEventListener('touchend', stopResize);
        }

        // Text Editing Functionality
        function initTextEditing() {
            const editableElements = document.querySelectorAll('.central-engine, .smart-tasks, .node-label, .text-box, .custom-label-box, .network-node, .workflow-line');
            
            editableElements.forEach(element => {
                if (element.classList.contains('workflow-line')) {
                    element.addEventListener('dblclick', startLineEditing);
                } else {
                    element.addEventListener('dblclick', startEditing);
                }
                
                // Add click event to select text elements for keyboard delete
                if (element.classList.contains('text-box') || element.classList.contains('node-label')) {
                    element.addEventListener('click', function(e) {
                        e.stopPropagation();
                        // Remove selected class from all elements
                        document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                        // Add selected class to clicked element
                        element.classList.add('selected');
                    });
                }
            });
        }

        function startEditing(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const element = e.currentTarget;
            
            // Handle different element types
            if (element.classList.contains('network-node')) {
                // For network nodes (icons), open the edit modal
                showEditIconModal(element);
                return;
            }
            
            if (element.classList.contains('text-box') || element.classList.contains('node-label')) {
                // For text boxes, use the edit modal instead of inline editing
                showEditTextBoxModal(element);
                return;
            }
            
            if (element.classList.contains('custom-label-box')) {
                // For label boxes, use the edit modal
                showEditLabelBoxModal(element);
                return;
            }
            
            // For central-engine and smart-tasks, do inline editing
            const currentText = element.textContent.trim();
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentText;
            input.className = 'editing-input';
            input.style.cssText = `
                background: transparent;
                border: 2px solid #3498db;
                outline: none;
                font-size: inherit;
                font-weight: inherit;
                color: inherit;
                text-align: center;
                width: 100%;
                min-width: 60px;
                border-radius: 4px;
            `;
            
            element.innerHTML = '';
            element.appendChild(input);
            input.focus();
            input.select();
            
            input.addEventListener('blur', () => finishEditing(element, input.value));
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }

        function finishEditing(element, newText) {
            element.textContent = newText || element.textContent;
            saveLayout();
        }

        // Context Menu Functionality
        function initContextMenu() {
            document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                
                const target = e.target;
                const contextMenu = document.getElementById('contextMenu');
                
                // Determine context type
                let contextType = 'background';
                let targetElement = null;
                
                console.log('Context menu triggered on:', target);
                console.log('Target classes:', target.className);
                console.log('Target tag:', target.tagName);
                
                // Check if target or its parent is a workflow element
                let elementToCheck = target;
                while (elementToCheck && elementToCheck !== document.body) {
                    if (elementToCheck.classList.contains('network-node') || 
                        elementToCheck.classList.contains('custom-label-box') ||
                        elementToCheck.classList.contains('node-label') ||
                        elementToCheck.classList.contains('text-box') ||
                        elementToCheck.classList.contains('central-engine') ||
                        elementToCheck.classList.contains('smart-tasks') ||
                        elementToCheck.classList.contains('workflow-line')) {
                        contextType = 'element';
                        targetElement = elementToCheck;
                        console.log('Found workflow element:', elementToCheck.className);
                        break;
                    }
                    elementToCheck = elementToCheck.parentElement;
                }
                
                // Show appropriate menu
                if (contextType === 'element') {
                    // Hide background menu and show element menu
                    document.getElementById('contextMenu').style.display = 'none';
                    const elementMenu = document.getElementById('elementContextMenu');
                    elementMenu.style.display = 'block';
                    elementMenu.style.left = e.clientX + 'px';
                    elementMenu.style.top = e.clientY + 'px';
                    currentTargetElement = targetElement; // Store the actual element reference globally
                    contextMenu = elementMenu; // Use element menu for positioning
                } else {
                    // Hide element menu and show background menu
                    document.getElementById('elementContextMenu').style.display = 'none';
                    currentTargetElement = null; // Clear target element for background menu
                    contextMenu.style.display = 'block';
                }
                
                // Position and show context menu
                const menuWidth = 200; // min-width from CSS
                const menuHeight = 200; // estimated height
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Calculate position with viewport bounds checking
                let left = e.clientX;
                let top = e.clientY;
                
                // Adjust if menu would go off right edge
                if (left + menuWidth > viewportWidth) {
                    left = viewportWidth - menuWidth - 10;
                }
                
                // Adjust if menu would go off bottom edge
                if (top + menuHeight > viewportHeight) {
                    top = viewportHeight - menuHeight - 10;
                }
                
                // Ensure menu doesn't go off left or top edges
                left = Math.max(10, left);
                top = Math.max(10, top);
                
                contextMenu.style.left = left + 'px';
                contextMenu.style.top = top + 'px';
                contextMenu.style.display = 'block';
                
                // Store target element for context menu actions
                contextMenu.dataset.targetElement = targetElement ? targetElement.className : '';
                
                // Add event listeners to context menu items
                contextMenu.querySelectorAll('.context-menu-item').forEach(item => {
                    item.addEventListener('click', function() {
                        const action = this.dataset.action;
                        handleContextMenuAction(action, targetElement);
                        contextMenu.style.display = 'none';
                        document.getElementById('elementContextMenu').style.display = 'none';
                    });
                });
            });
            
            // Hide context menus when clicking elsewhere
            document.addEventListener('click', function() {
                document.getElementById('contextMenu').style.display = 'none';
                document.getElementById('elementContextMenu').style.display = 'none';
            });
            
            // Add event listeners to element context menu
            const elementContextMenu = document.getElementById('elementContextMenu');
            elementContextMenu.addEventListener('click', function(e) {
                if (e.target.classList.contains('context-menu-item')) {
                    const action = e.target.dataset.action;
                    console.log('Element context menu action:', action, 'on element:', currentTargetElement);
                    handleContextMenuAction(action, currentTargetElement);
                    elementContextMenu.style.display = 'none';
                }
            });
        }

        function handleContextMenuAction(action, targetElement) {
            console.log('Context menu action:', action, 'on element:', targetElement);
            console.log('Target element classes:', targetElement ? targetElement.className : 'none');
            
            switch (action) {
                case 'addIcon':
                    showIconModal();
                    break;
                case 'addLabelBox':
                    showLabelBoxModal();
                    break;
                case 'addText':
                    showTextBoxModal();
                    break;
                case 'addLine':
                    showLineModal();
                    break;
                case 'editBgColors':
                    showBgColorModal();
                    break;
                case 'toggleMenu':
                    toggleTopMenu();
                    break;
                case 'edit':
                    if (targetElement) {
                        console.log('Edit action triggered on:', targetElement.className);
                        if (targetElement.classList.contains('network-node')) {
                            console.log('Opening edit icon modal');
                            showEditIconModal(targetElement);
                        } else if (targetElement.classList.contains('node-label') || targetElement.classList.contains('text-box')) {
                            console.log('Opening edit text box modal');
                            showEditTextBoxModal(targetElement);
                        } else if (targetElement.classList.contains('custom-label-box')) {
                            console.log('Opening edit label box modal');
                            showEditLabelBoxModal(targetElement);
                        } else if (targetElement.classList.contains('workflow-line')) {
                            console.log('Opening edit line modal');
                            showEditLineModal(targetElement);
                        } else {
                            // For central-engine and smart-tasks, use inline editing
                            console.log('Using inline editing for:', targetElement.className);
                            startEditing({ currentTarget: targetElement });
                        }
                    } else {
                        console.log('No target element for edit action');
                    }
                    break;
                case 'delete':
                    if (targetElement && !targetElement.classList.contains('central-engine') && targetElement.id !== 'smartTasks') {
                        targetElement.remove();
                        saveLayout();
                    }
                    break;
                case 'sendToFront':
                    if (targetElement) {
                        sendToFront(targetElement);
                    }
                    break;
                case 'sendToBack':
                    if (targetElement) {
                        sendToBack(targetElement);
                    }
                    break;
                case 'copy':
                    if (targetElement) {
                        copyElement(targetElement);
                    }
                    break;
                case 'paste':
                    pasteElement();
                    break;
            }
        }

        // Modal Functionality
        function initModals() {
            // Icon modal
            const iconModal = document.getElementById('iconModal');
            const createIcon = document.getElementById('createIcon');
            const cancelIcon = document.getElementById('cancelIcon');
            
            if (createIcon) {
                createIcon.addEventListener('click', function() {
                    const selectedIconElement = document.querySelector('.icon-library i.selected');
                    
                    if (!selectedIconElement) {
                        alert('Please select an icon');
                        return;
                    }
                    
                    createNewIcon('', selectedIconElement.dataset.icon);
                    iconModal.style.display = 'none';
                    selectedIcon = null;
                });
            }
            
            if (cancelIcon) {
                cancelIcon.addEventListener('click', function() {
                    iconModal.style.display = 'none';
                    selectedIcon = null;
                });
            }
            
            // Icon selection
            document.querySelectorAll('.icon-library i').forEach(icon => {
                icon.addEventListener('click', function() {
                    document.querySelectorAll('.icon-library i').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
            
            // Label box modal
            const labelBoxModal = document.getElementById('labelBoxModal');
            const labelBoxName = document.getElementById('labelBoxName');
            const createLabelBox = document.getElementById('createLabelBox');
            const cancelLabelBox = document.getElementById('cancelLabelBox');
            
            if (createLabelBox) {
                createLabelBox.addEventListener('click', function() {
                    const name = labelBoxName.value.trim();
                    const fontSize = document.getElementById('labelBoxFontSize').value;
                    const selectedShapeElement = document.querySelector('.shape-selector .shape-option.selected');
                    const selectedIconElement = document.querySelector('#labelBoxModal .icon-library i.selected');
                    const selectedColorElement = document.querySelector('.color-selector .color-option.selected');
                    
                    if (!name) {
                        alert('Please enter a label name');
                        return;
                    }
                    
                    if (!selectedShapeElement) {
                        alert('Please select a shape');
                        return;
                    }
                    
                    if (!selectedIconElement) {
                        alert('Please select an icon');
                        return;
                    }
                    
                    if (!selectedColorElement) {
                        alert('Please select a color');
                        return;
                    }
                    
                    createNewLabelBox(name, selectedShapeElement.dataset.shape, selectedIconElement.dataset.icon, selectedColorElement.dataset.color, fontSize);
                    labelBoxModal.style.display = 'none';
                    labelBoxName.value = '';
                    selectedShape = null;
                    selectedLabelIcon = null;
                    selectedColor = '#667eea';
                });
            }
            
            if (cancelLabelBox) {
                cancelLabelBox.addEventListener('click', function() {
                    labelBoxModal.style.display = 'none';
                    labelBoxName.value = '';
                    selectedShape = null;
                    selectedLabelIcon = null;
                    selectedColor = '#667eea';
                });
            }
            
            // Shape selection
            document.querySelectorAll('.shape-selector .shape-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.shape-selector .shape-option').forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
            
            // Color selection
            document.querySelectorAll('.color-selector .color-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.color-selector .color-option').forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
            
            // Text box modal
            const textBoxModal = document.getElementById('textBoxModal');
            const textBoxContent = document.getElementById('textBoxContent');
            const createTextBox = document.getElementById('createTextBox');
            const cancelTextBox = document.getElementById('cancelTextBox');
            
            if (createTextBox) {
                createTextBox.addEventListener('click', function() {
                    const content = textBoxContent.value.trim();
                    const fontSize = document.getElementById('textBoxFontSize').value;
                    const fontFamily = document.getElementById('textBoxFontFamily').value;
                    const fontColor = document.getElementById('textBoxFontColor').value;
                    
                    if (!content) {
                        alert('Please enter text content');
                        return;
                    }
                    
                    createNewTextBox(content, fontSize, fontFamily, fontColor);
                    textBoxModal.style.display = 'none';
                    textBoxContent.value = '';
                });
            }
            
            if (cancelTextBox) {
                cancelTextBox.addEventListener('click', function() {
                    textBoxModal.style.display = 'none';
                    textBoxContent.value = '';
                });
            }
            
            // Background color modal
            const bgColorModal = document.getElementById('bgColorModal');
            const applyBgColors = document.getElementById('applyBgColors');
            const resetBgColors = document.getElementById('resetBgColors');
            const closeBgColorModal = document.getElementById('closeBgColorModal');
            
            if (applyBgColors) {
                applyBgColors.addEventListener('click', function() {
                    applyBackgroundColors();
                    bgColorModal.style.display = 'none';
                });
            }
            
            if (resetBgColors) {
                resetBgColors.addEventListener('click', function() {
                    resetBackgroundColors();
                });
            }
            
            if (closeBgColorModal) {
                closeBgColorModal.addEventListener('click', function() {
                    bgColorModal.style.display = 'none';
                });
            }
            
            // Theme selection functionality
            document.querySelectorAll('.theme-option').forEach(themeOption => {
                themeOption.addEventListener('click', function() {
                    // Remove selected class from all themes
                    document.querySelectorAll('.theme-option').forEach(opt => opt.classList.remove('selected'));
                    // Add selected class to clicked theme
                    this.classList.add('selected');
                    
                    // Apply theme colors
                    const theme = this.dataset.theme;
                    applyThemeColors(theme);
                });
            });
            
            // Edit Icon Modal
            const editIconModal = document.getElementById('editIconModal');
            const updateIcon = document.getElementById('updateIcon');
            const cancelEditIcon = document.getElementById('cancelEditIcon');
            
            if (updateIcon) {
                updateIcon.addEventListener('click', function() {
                    const element = editIconModal.editingElement;
                    const selectedIconElement = document.querySelector('#editIconModal .icon-library i.selected');
                    
                    if (!selectedIconElement) {
                        alert('Please select an icon');
                        return;
                    }
                    
                    // Update the icon
                    const icon = element.querySelector('i');
                    
                    if (icon) icon.className = selectedIconElement.dataset.icon;
                    
                    editIconModal.style.display = 'none';
                    saveLayout();
                });
            }
            
            if (cancelEditIcon) {
                cancelEditIcon.addEventListener('click', function() {
                    editIconModal.style.display = 'none';
                    // Clear any selections
                    document.querySelectorAll('#editIconModal .icon-library i').forEach(i => i.classList.remove('selected'));
                });
            }
            
            // Edit Text Box Modal
            const editTextBoxModal = document.getElementById('editTextBoxModal');
            const updateTextBox = document.getElementById('updateTextBox');
            const cancelEditTextBox = document.getElementById('cancelEditTextBox');
            
            if (updateTextBox) {
                updateTextBox.addEventListener('click', function() {
                    const element = editTextBoxModal.editingElement;
                    const content = document.getElementById('editTextBoxContent').value.trim();
                    const fontSize = document.getElementById('editTextBoxFontSize').value;
                    const fontFamily = document.getElementById('editTextBoxFontFamily').value;
                    const fontColor = document.getElementById('editTextBoxFontColor').value;
                    
                    if (!content) {
                        alert('Please enter text content');
                        return;
                    }
                    
                    if (!element) {
                        alert('Error: No element to update');
                        return;
                    }
                    
                    // Update the text box - preserve line breaks
                    element.innerHTML = content.replace(/\n/g, '<br>');
                    element.style.fontSize = fontSize;
                    element.style.fontFamily = fontFamily;
                    element.style.color = fontColor;
                    
                    editTextBoxModal.style.display = 'none';
                    saveLayout();
                });
            }
            
            if (cancelEditTextBox) {
                cancelEditTextBox.addEventListener('click', function() {
                    editTextBoxModal.style.display = 'none';
                    // Clear form
                    document.getElementById('editTextBoxContent').value = '';
                    document.getElementById('editTextBoxFontSize').value = '12px';
                    document.getElementById('editTextBoxFontFamily').value = 'Arial, sans-serif';
                    document.getElementById('editTextBoxFontColor').value = '#2c3e50';
                });
            }
            
            // Edit Label Box Modal
            const editLabelBoxModal = document.getElementById('editLabelBoxModal');
            const updateLabelBox = document.getElementById('updateLabelBox');
            const cancelEditLabelBox = document.getElementById('cancelEditLabelBox');
            
            if (updateLabelBox) {
                updateLabelBox.addEventListener('click', function() {
                    const element = editLabelBoxModal.editingElement;
                    const name = document.getElementById('editLabelBoxName').value.trim();
                    const fontSize = document.getElementById('editLabelBoxFontSize').value;
                    const selectedIconElement = document.querySelector('#editLabelBoxModal .icon-library i.selected');
                    const selectedColorElement = document.querySelector('#editLabelBoxModal .color-option.selected');
                    const selectedShapeElement = document.querySelector('#editLabelBoxModal .shape-option.selected');
                    
                    if (!name) {
                        alert('Please enter a label name');
                        return;
                    }
                    
                    if (!selectedIconElement) {
                        alert('Please select an icon');
                        return;
                    }
                    
                    if (!selectedColorElement) {
                        alert('Please select a color');
                        return;
                    }
                    
                    if (!selectedShapeElement) {
                        alert('Please select a shape');
                        return;
                    }
                    
                    // Update the label box
                    const icon = element.querySelector('i');
                    const nameText = element.querySelector('div');
                    
                    if (icon) icon.className = selectedIconElement.dataset.icon;
                    if (nameText) {
                        nameText.textContent = name;
                        nameText.style.fontSize = fontSize;
                    }
                    element.style.background = selectedColorElement.dataset.color;
                    
                    // Update shape
                    const shape = selectedShapeElement.dataset.shape;
                    element.dataset.shape = shape;
                    
                    // Apply shape styling
                    if (shape === 'circle') {
                        element.style.borderRadius = '50%';
                    } else if (shape === 'square') {
                        element.style.borderRadius = '0';
                    } else if (shape === 'rectangle') {
                        element.style.borderRadius = '10px';
                    } else if (shape === 'rounded-rectangle') {
                        element.style.borderRadius = '20px';
                    } else if (shape === 'diamond') {
                        element.style.clipPath = 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)';
                    } else if (shape === 'hexagon') {
                        element.style.clipPath = 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)';
                    } else if (shape === 'triangle') {
                        element.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
                    }
                    
                    editLabelBoxModal.style.display = 'none';
                    saveLayout();
                });
            }
            
            if (cancelEditLabelBox) {
                cancelEditLabelBox.addEventListener('click', function() {
                    editLabelBoxModal.style.display = 'none';
                    // Clear form
                    document.getElementById('editLabelBoxName').value = '';
                    document.getElementById('editLabelBoxFontSize').value = '12px';
                    document.querySelectorAll('#editLabelBoxModal .icon-library i').forEach(i => i.classList.remove('selected'));
                    document.querySelectorAll('#editLabelBoxModal .color-option').forEach(opt => opt.classList.remove('selected'));
                });
            }
            
            // Icon selection for edit modals
            document.querySelectorAll('#editIconModal .icon-library i').forEach(icon => {
                icon.addEventListener('click', function() {
                    document.querySelectorAll('#editIconModal .icon-library i').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
            
            document.querySelectorAll('#editLabelBoxModal .icon-library i').forEach(icon => {
                icon.addEventListener('click', function() {
                    document.querySelectorAll('#editLabelBoxModal .icon-library i').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
            
            // Color selection for edit label box modal
            document.querySelectorAll('#editLabelBoxModal .color-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('#editLabelBoxModal .color-option').forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
            
            // Line Modal
            const lineModal = document.getElementById('lineModal');
            const createLine = document.getElementById('createLine');
            const cancelLine = document.getElementById('cancelLine');
            
            if (createLine) {
                createLine.addEventListener('click', function() {
                    const selectedLineTypeElement = document.querySelector('#lineModal .line-type-option.selected');
                    const lineColor = document.getElementById('lineColor').value;
                    const lineThickness = document.getElementById('lineThickness').value;
                    
                    if (!selectedLineTypeElement) {
                        alert('Please select a line type');
                        return;
                    }
                    
                    const lineType = selectedLineTypeElement.dataset.type;
                    createNewLine(lineType, lineColor, lineThickness);
                    lineModal.style.display = 'none';
                    
                    // Reset selections
                    document.querySelectorAll('#lineModal .line-type-option').forEach(opt => opt.classList.remove('selected'));
                });
            }
            
            if (cancelLine) {
                cancelLine.addEventListener('click', function() {
                    lineModal.style.display = 'none';
                    document.querySelectorAll('#lineModal .line-type-option').forEach(opt => opt.classList.remove('selected'));
                });
            }
            
            // Line type selection
            document.querySelectorAll('#lineModal .line-type-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('#lineModal .line-type-option').forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
            
            // Edit Line Modal
            const editLineModal = document.getElementById('editLineModal');
            const updateLine = document.getElementById('updateLine');
            const cancelEditLine = document.getElementById('cancelEditLine');
            
            if (updateLine) {
                updateLine.addEventListener('click', function() {
                    const element = editLineModal.editingElement;
                    const selectedLineTypeElement = document.querySelector('#editLineModal .line-type-option.selected');
                    const lineColor = document.getElementById('editLineColor').value;
                    const lineThickness = document.getElementById('editLineThickness').value;
                    
                    if (!selectedLineTypeElement) {
                        alert('Please select a line type');
                        return;
                    }
                    
                    const lineType = selectedLineTypeElement.dataset.type;
                    
                    // Update line properties
                    element.dataset.lineType = lineType;
                    element.dataset.lineColor = lineColor;
                    element.dataset.lineThickness = lineThickness;
                    
                    // Reapply styling
                    applyLineStyling(element, lineType, lineColor, lineThickness);
                    
                    editLineModal.style.display = 'none';
                    saveLayout();
                });
            }
            
            if (cancelEditLine) {
                cancelEditLine.addEventListener('click', function() {
                    editLineModal.style.display = 'none';
                    document.querySelectorAll('#editLineModal .line-type-option').forEach(opt => opt.classList.remove('selected'));
                });
            }
            
            // Edit line type selection
            document.querySelectorAll('#editLineModal .line-type-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('#editLineModal .line-type-option').forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
        }

        // Element Creation Functions
        function createNewIcon(text, iconClass) {
            const container = document.querySelector('.workflow-container');
            
            const newNode = document.createElement('div');
            newNode.className = 'network-node';
            newNode.style.position = 'absolute';
            newNode.style.zIndex = '15';
            newNode.style.width = '80px';
            newNode.style.height = '80px';
            newNode.style.background = 'white';
            newNode.style.borderRadius = '50%';
            newNode.style.border = '3px solid #667eea';
            newNode.style.display = 'flex';
            newNode.style.alignItems = 'center';
            newNode.style.justifyContent = 'center';
            newNode.style.cursor = 'move';
            newNode.style.boxShadow = '0 4px 20px rgba(0,0,0,0.2)';
            
            // Position at center of container initially
            const containerRect = container.getBoundingClientRect();
            newNode.style.left = (containerRect.width / 2 - 40) + 'px';
            newNode.style.top = (containerRect.height / 2 - 40) + 'px';
            
            // Add icon
            const icon = document.createElement('i');
            icon.className = iconClass;
            icon.style.fontSize = '24px';
            icon.style.color = '#667eea';
            icon.style.pointerEvents = 'none';
            
            newNode.appendChild(icon);
            container.appendChild(newNode);
            
            // Make it draggable, editable, and resizable
            newNode.addEventListener('mousedown', startDrag);
            newNode.addEventListener('touchstart', startDrag);
            newNode.addEventListener('dblclick', startEditing);
            makeResizable(newNode);
            
            saveLayout();
        }

        function createNewTextBox(content, fontSize, fontFamily, fontColor) {
            const container = document.querySelector('.workflow-container');
            
            const newTextBox = document.createElement('div');
            newTextBox.className = 'text-box';
            // Preserve line breaks by converting \n to <br>
            newTextBox.innerHTML = content.replace(/\n/g, '<br>');
            newTextBox.style.fontSize = fontSize;
            newTextBox.style.fontFamily = fontFamily;
            newTextBox.style.color = fontColor;
            
            // Position at center of container initially
            const containerRect = container.getBoundingClientRect();
            newTextBox.style.left = (containerRect.width / 2 - 100) + 'px';
            newTextBox.style.top = (containerRect.height / 2 - 20) + 'px';
            
            container.appendChild(newTextBox);
            
            // Make it draggable, editable, and resizable
            newTextBox.addEventListener('mousedown', startDrag);
            newTextBox.addEventListener('touchstart', startDrag);
            newTextBox.addEventListener('dblclick', startEditing);
            newTextBox.addEventListener('click', function(e) {
                e.stopPropagation();
                // Remove selected class from all elements
                document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                // Add selected class to clicked element
                newTextBox.classList.add('selected');
            });
            makeResizable(newTextBox);
            
            saveLayout();
        }

        function createNewLabelBox(name, shape, iconClass, color, fontSize = '12px') {
            const container = document.querySelector('.workflow-container');
            
            const newLabelBox = document.createElement('div');
            newLabelBox.className = 'custom-label-box';
            newLabelBox.style.position = 'absolute';
            newLabelBox.style.width = '120px';
            newLabelBox.style.height = '80px';
            newLabelBox.style.background = color;
            newLabelBox.style.display = 'flex';
            newLabelBox.style.flexDirection = 'column';
            newLabelBox.style.alignItems = 'center';
            newLabelBox.style.justifyContent = 'center';
            newLabelBox.style.cursor = 'move';
            newLabelBox.dataset.shape = shape;
            
            // Apply shape
            if (shape === 'circle') {
                newLabelBox.style.borderRadius = '50%';
            } else if (shape === 'square') {
                newLabelBox.style.borderRadius = '0';
            } else if (shape === 'rectangle') {
                newLabelBox.style.borderRadius = '10px';
            } else if (shape === 'rounded-rectangle') {
                newLabelBox.style.borderRadius = '20px';
            } else if (shape === 'diamond') {
                newLabelBox.style.clipPath = 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)';
            } else if (shape === 'hexagon') {
                newLabelBox.style.clipPath = 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)';
            } else if (shape === 'triangle') {
                newLabelBox.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
            }
            
            // Position at center of container initially
            const containerRect = container.getBoundingClientRect();
            newLabelBox.style.left = (containerRect.width / 2 - 60) + 'px';
            newLabelBox.style.top = (containerRect.height / 2 - 40) + 'px';
            
            // Add icon
            const icon = document.createElement('i');
            icon.className = iconClass;
            icon.style.fontSize = '20px';
            icon.style.color = 'white';
            icon.style.marginBottom = '5px';
            icon.style.pointerEvents = 'none';
            
            // Add name text
            const nameText = document.createElement('div');
            nameText.textContent = name;
            nameText.style.color = 'white';
            nameText.style.fontSize = fontSize;
            nameText.style.fontWeight = 'bold';
            nameText.style.textAlign = 'center';
            nameText.style.pointerEvents = 'none';
            
            newLabelBox.appendChild(icon);
            newLabelBox.appendChild(nameText);
            container.appendChild(newLabelBox);
            
            // Make it draggable, editable, and resizable
            newLabelBox.addEventListener('mousedown', startDrag);
            newLabelBox.addEventListener('touchstart', startDrag);
            newLabelBox.addEventListener('dblclick', startEditing);
            newLabelBox.addEventListener('click', function(e) {
                e.stopPropagation();
                // Remove selected class from all elements
                document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                // Add selected class to clicked element
                newLabelBox.classList.add('selected');
            });
            makeResizable(newLabelBox);
            
            saveLayout();
        }

        // Modal Display Functions
        function showIconModal() {
            document.getElementById('iconModal').style.display = 'block';
        }

        function showLabelBoxModal() {
            document.getElementById('labelBoxModal').style.display = 'block';
        }

        function showTextBoxModal() {
            document.getElementById('textBoxModal').style.display = 'block';
        }

        function showBgColorModal() {
            document.getElementById('bgColorModal').style.display = 'block';
        }

        // Layering Functions
        function sendToFront(element) {
            // Set a very high z-index to ensure it's above everything
            element.style.zIndex = '2000';
            saveLayout();
        }

        function sendToBack(element) {
            // Set a very low z-index to ensure it's behind everything
            element.style.zIndex = '0';
            saveLayout();
        }

        // Copy and Paste Functions
        function copyElement(element) {
            console.log('Copy function called with element:', element);
            
            const elementData = {
                type: getElementType(element),
                className: element.className,
                style: {
                    left: element.style.left,
                    top: element.style.top,
                    width: element.style.width,
                    height: element.style.height,
                    fontSize: element.style.fontSize,
                    fontFamily: element.style.fontFamily,
                    color: element.style.color,
                    background: element.style.background,
                    zIndex: element.style.zIndex
                },
                dataset: {},
                content: element.innerHTML
            };

            // Copy dataset attributes
            for (let key in element.dataset) {
                elementData.dataset[key] = element.dataset[key];
            }

            // Get specific data based on element type
            if (element.classList.contains('network-node')) {
                const icon = element.querySelector('i');
                elementData.iconClass = icon ? icon.className : '';
                elementData.iconSize = icon ? icon.style.fontSize : '';
            } else if (element.classList.contains('custom-label-box')) {
                console.log('=== COPYING CUSTOM LABEL BOX ===');
                console.log('Element HTML:', element.outerHTML);
                console.log('Element children:', element.children);
                
                const icon = element.querySelector('i');
                const text = element.querySelector('div');
                
                console.log('Icon element found:', icon);
                console.log('Text element found:', text);
                
                // More comprehensive icon detection
                if (icon) {
                    elementData.iconClass = icon.className;
                    elementData.iconSize = icon.style.fontSize;
                    console.log('✅ Found icon with class:', icon.className, 'size:', icon.style.fontSize);
                    console.log('Icon outerHTML:', icon.outerHTML);
                } else {
                    console.log('❌ No icon found in custom-label-box');
                    console.log('All child elements:', Array.from(element.children).map(child => ({
                        tagName: child.tagName,
                        className: child.className,
                        outerHTML: child.outerHTML
                    })));
                    elementData.iconClass = '';
                    elementData.iconSize = '';
                }
                
                if (text) {
                    elementData.textContent = text.textContent;
                    console.log('✅ Found text:', text.textContent);
                } else {
                    console.log('❌ No text found in custom-label-box');
                    elementData.textContent = '';
                }
                
                elementData.shape = element.dataset.shape;
                elementData.background = element.style.background;
                
                console.log('=== FINAL COPIED DATA ===');
                console.log('Copied custom-label-box data:', {
                    iconClass: elementData.iconClass,
                    iconSize: elementData.iconSize,
                    textContent: elementData.textContent,
                    shape: elementData.shape,
                    background: elementData.background
                });
                console.log('=== END COPYING ===');
            } else if (element.classList.contains('text-box') || element.classList.contains('node-label')) {
                // Get text content without resize handles
                let textContent = '';
                const textNodes = Array.from(element.childNodes).filter(node => 
                    node.nodeType === Node.TEXT_NODE || 
                    (node.nodeType === Node.ELEMENT_NODE && !node.classList.contains('resize-handle'))
                );
                textNodes.forEach(node => {
                    if (node.nodeType === Node.TEXT_NODE) {
                        textContent += node.textContent;
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        textContent += node.textContent;
                    }
                });
                elementData.textContent = textContent;
                console.log('Copied text content:', textContent);
            } else if (element.classList.contains('central-engine') || element.classList.contains('smart-tasks')) {
                // Get text content for central-engine and smart-tasks elements
                let textContent = '';
                const textNodes = Array.from(element.childNodes).filter(node => 
                    node.nodeType === Node.TEXT_NODE || 
                    (node.nodeType === Node.ELEMENT_NODE && !node.classList.contains('resize-handle'))
                );
                textNodes.forEach(node => {
                    if (node.nodeType === Node.TEXT_NODE) {
                        textContent += node.textContent;
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        textContent += node.textContent;
                    }
                });
                elementData.textContent = textContent;
                console.log('Copied central-engine/smart-tasks text content:', textContent);
            } else if (element.id === 'workflowTitle') {
                // Get text content for workflow title element
                let textContent = '';
                const textNodes = Array.from(element.childNodes).filter(node => 
                    node.nodeType === Node.TEXT_NODE || 
                    (node.nodeType === Node.ELEMENT_NODE && !node.classList.contains('resize-handle'))
                );
                textNodes.forEach(node => {
                    if (node.nodeType === Node.TEXT_NODE) {
                        textContent += node.textContent;
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        textContent += node.textContent;
                    }
                });
                elementData.textContent = textContent;
                elementData.fontSize = element.style.fontSize;
                console.log('Copied workflow-title text content:', textContent, 'fontSize:', elementData.fontSize);
            }

            copiedElementData = elementData;
            console.log('Element copied successfully:', elementData);
            console.log('copiedElementData variable set to:', copiedElementData);
        }

        // Add debounce to prevent multiple paste operations
        let isPasting = false;
        
        function pasteElement() {
            if (isPasting) {
                console.log('Paste already in progress, ignoring duplicate call');
                return;
            }
            
            console.log('Paste function called');
            console.log('copiedElementData is:', copiedElementData);
            
            if (!copiedElementData) {
                alert('No element copied. Please copy an element first.');
                return;
            }
            
            isPasting = true;

            const container = document.querySelector('.workflow-container');
            const containerRect = container.getBoundingClientRect();
            
            // Create new element based on copied data
            const newElement = document.createElement('div');
            newElement.className = copiedElementData.className;
            
            // Apply styles with slight offset to avoid exact overlap
            const offsetX = 20;
            const offsetY = 20;
            const originalLeft = parseFloat(copiedElementData.style.left) || 0;
            const originalTop = parseFloat(copiedElementData.style.top) || 0;
            
            newElement.style.left = (originalLeft + offsetX) + 'px';
            newElement.style.top = (originalTop + offsetY) + 'px';
            newElement.style.width = copiedElementData.style.width || '';
            newElement.style.height = copiedElementData.style.height || '';
            newElement.style.fontSize = copiedElementData.style.fontSize || '';
            newElement.style.fontFamily = copiedElementData.style.fontFamily || '';
            newElement.style.color = copiedElementData.style.color || '';
            newElement.style.background = copiedElementData.style.background || '';
            newElement.style.zIndex = copiedElementData.style.zIndex || '';

            // Apply dataset attributes
            for (let key in copiedElementData.dataset) {
                newElement.dataset[key] = copiedElementData.dataset[key];
            }

            // Add content based on element type
            if (copiedElementData.type === 'network-node') {
                if (copiedElementData.iconClass) {
                    const icon = document.createElement('i');
                    icon.className = copiedElementData.iconClass;
                    if (copiedElementData.iconSize) {
                        icon.style.fontSize = copiedElementData.iconSize;
                    }
                    newElement.appendChild(icon);
                }
            } else if (copiedElementData.type === 'custom-label-box') {
                console.log('=== PASTING CUSTOM LABEL BOX ===');
                console.log('Pasting custom label box with data:', copiedElementData);
                console.log('Icon class to paste:', copiedElementData.iconClass);
                console.log('Icon size to paste:', copiedElementData.iconSize);
                console.log('Text content to paste:', copiedElementData.textContent);
                console.log('Background to paste:', copiedElementData.background);
                console.log('Shape to paste:', copiedElementData.shape);
                
                // Set up the container styling
                newElement.style.display = 'flex';
                newElement.style.flexDirection = 'column';
                newElement.style.alignItems = 'center';
                newElement.style.justifyContent = 'center';
                newElement.style.cursor = 'move';
                
                if (copiedElementData.background) {
                    newElement.style.background = copiedElementData.background;
                }
                
                if (copiedElementData.shape) {
                    newElement.dataset.shape = copiedElementData.shape;
                    // Apply shape styling
                    if (copiedElementData.shape === 'circle') {
                        newElement.style.borderRadius = '50%';
                    } else if (copiedElementData.shape === 'square') {
                        newElement.style.borderRadius = '0';
                    } else if (copiedElementData.shape === 'rectangle') {
                        newElement.style.borderRadius = '10px';
                    } else if (copiedElementData.shape === 'rounded-rectangle') {
                        newElement.style.borderRadius = '20px';
                    } else if (copiedElementData.shape === 'diamond') {
                        newElement.style.clipPath = 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)';
                    } else if (copiedElementData.shape === 'hexagon') {
                        newElement.style.clipPath = 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)';
                    } else if (copiedElementData.shape === 'triangle') {
                        newElement.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
                    }
                }
                
                if (copiedElementData.iconClass && copiedElementData.iconClass.trim() !== '') {
                    console.log('Creating icon with class:', copiedElementData.iconClass);
                    const icon = document.createElement('i');
                    icon.className = copiedElementData.iconClass;
                    icon.style.color = 'white';
                    icon.style.marginBottom = '5px';
                    icon.style.pointerEvents = 'none';
                    if (copiedElementData.iconSize) {
                        icon.style.fontSize = copiedElementData.iconSize;
                    }
                    newElement.appendChild(icon);
                    console.log('✅ Added icon:', copiedElementData.iconClass, 'with size:', copiedElementData.iconSize);
                    console.log('Icon element created:', icon.outerHTML);
                } else {
                    console.log('❌ No icon class found to paste or icon class is empty');
                    console.log('Icon class value:', copiedElementData.iconClass);
                    console.log('Icon class type:', typeof copiedElementData.iconClass);
                    console.log('Icon class length:', copiedElementData.iconClass ? copiedElementData.iconClass.length : 'undefined');
                }
                
                if (copiedElementData.textContent && copiedElementData.textContent.trim() !== '') {
                    const text = document.createElement('div');
                    text.textContent = copiedElementData.textContent;
                    text.style.color = 'white';
                    text.style.fontWeight = 'bold';
                    text.style.textAlign = 'center';
                    text.style.pointerEvents = 'none';
                    newElement.appendChild(text);
                    console.log('Added text:', copiedElementData.textContent);
                } else {
                    console.log('No text content found to paste or text is empty');
                }
            } else if (copiedElementData.type === 'text-box' || copiedElementData.type === 'node-label') {
                if (copiedElementData.textContent) {
                    const contentWithBreaks = copiedElementData.textContent.replace(/\n/g, '<br>');
                    newElement.innerHTML = contentWithBreaks;
                    console.log('Pasted text content:', contentWithBreaks);
                } else {
                    console.log('No text content to paste for text element');
                }
            } else if (copiedElementData.type === 'central-engine' || copiedElementData.type === 'smart-tasks') {
                if (copiedElementData.textContent) {
                    const contentWithBreaks = copiedElementData.textContent.replace(/\n/g, '<br>');
                    newElement.innerHTML = contentWithBreaks;
                    console.log('Pasted central-engine/smart-tasks text content:', contentWithBreaks);
                } else {
                    console.log('No text content to paste for central-engine/smart-tasks element');
                }
            } else if (copiedElementData.type === 'workflow-title') {
                // For workflow title, we need to create a proper title element with all styling
                newElement.id = 'workflowTitle_' + Date.now(); // Give it a unique ID
                newElement.className = 'workflow-title'; // Add a class for styling
                
                if (copiedElementData.textContent) {
                    const contentWithBreaks = copiedElementData.textContent.replace(/\n/g, '<br>');
                    newElement.innerHTML = contentWithBreaks;
                    
                    // Apply all the styling from the original title
                    newElement.style.position = 'absolute';
                    newElement.style.fontSize = copiedElementData.fontSize || '2.5rem';
                    newElement.style.fontWeight = 'bold';
                    newElement.style.color = '#2c3e50';
                    newElement.style.textAlign = 'center';
                    newElement.style.cursor = 'move';
                    newElement.style.userSelect = 'none';
                    newElement.style.zIndex = '10';
                    newElement.style.padding = '10px';
                    newElement.style.borderRadius = '10px';
                    newElement.style.background = 'rgba(255, 255, 255, 0.9)';
                    newElement.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
                    newElement.style.minWidth = '200px';
                    
                    // Add resize handle
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle se';
                    resizeHandle.style.cssText = `
                        position: absolute;
                        bottom: 0;
                        right: 0;
                        width: 10px;
                        height: 10px;
                        background: #3498db;
                        cursor: se-resize;
                        border-radius: 0 0 10px 0;
                    `;
                    newElement.appendChild(resizeHandle);
                    
                    console.log('Pasted workflow-title with full styling:', contentWithBreaks, 'fontSize:', copiedElementData.fontSize);
                } else {
                    console.log('No text content to paste for workflow-title element');
                }
            } else if (copiedElementData.type === 'workflow-line') {
                // For lines, we need to recreate the line content
                newElement.innerHTML = copiedElementData.content;
            }

            // Add to container
            container.appendChild(newElement);

            // Make it draggable, editable, and resizable
            newElement.addEventListener('mousedown', startDrag);
            newElement.addEventListener('touchstart', startDrag);
            newElement.addEventListener('dblclick', startEditing);
            
            // Add click event for all elements to enable selection and keyboard shortcuts
            newElement.addEventListener('click', function(e) {
                e.stopPropagation();
                // Remove selected class from all elements
                document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                // Add selected class to clicked element
                newElement.classList.add('selected');
            });
            
            makeResizable(newElement);

            // For lines, add line-specific functionality
            if (copiedElementData.type === 'workflow-line') {
                newElement.addEventListener('click', () => selectLine(newElement));
                // Add line endpoints and controls if needed
                // This would require more complex line recreation logic
            }

            saveLayout();
            console.log('Element pasted:', newElement);
            
            // Reset the flag after a short delay to allow for rapid successive pastes if needed
            setTimeout(() => {
                isPasting = false;
            }, 100);
        }

        function getElementType(element) {
            console.log('Getting element type for:', element.className, 'ID:', element.id);
            if (element.classList.contains('network-node')) return 'network-node';
            if (element.classList.contains('custom-label-box')) return 'custom-label-box';
            if (element.classList.contains('text-box')) return 'text-box';
            if (element.classList.contains('node-label')) return 'node-label';
            if (element.classList.contains('workflow-line')) return 'workflow-line';
            if (element.classList.contains('central-engine')) return 'central-engine';
            if (element.classList.contains('smart-tasks')) return 'smart-tasks';
            if (element.id === 'workflowTitle') return 'workflow-title';
            console.log('Unknown element type for:', element.className, 'ID:', element.id);
            return 'unknown';
        }

        // Edit Modal Functions
        function showEditIconModal(iconElement) {
            const modal = document.getElementById('editIconModal');
            
            // Find and select current icon
            const currentIcon = iconElement.querySelector('i');
            if (currentIcon) {
                const currentIconClass = currentIcon.className;
                document.querySelectorAll('#editIconModal .icon-library i').forEach(icon => {
                    icon.classList.remove('selected');
                    if (icon.dataset.icon === currentIconClass) {
                        icon.classList.add('selected');
                    }
                });
            }
            
            // Store reference to element being edited
            modal.editingElement = iconElement;
            modal.style.display = 'block';
        }

        function showEditTextBoxModal(textBoxElement) {
            const modal = document.getElementById('editTextBoxModal');
            const contentInput = document.getElementById('editTextBoxContent');
            const fontSizeSelect = document.getElementById('editTextBoxFontSize');
            const fontFamilySelect = document.getElementById('editTextBoxFontFamily');
            const fontColorInput = document.getElementById('editTextBoxFontColor');
            
            // Populate with current values - convert <br> back to \n for textarea
            const currentContent = textBoxElement.innerHTML.replace(/<br\s*\/?>/gi, '\n');
            contentInput.value = currentContent;
            fontSizeSelect.value = textBoxElement.style.fontSize || '12px';
            fontFamilySelect.value = textBoxElement.style.fontFamily || 'Arial, sans-serif';
            fontColorInput.value = textBoxElement.style.color || '#2c3e50';
            
            // Store reference to element being edited (store the actual element, not a string)
            modal.editingElement = textBoxElement;
            modal.style.display = 'block';
        }

        function showEditLabelBoxModal(labelBoxElement) {
            const modal = document.getElementById('editLabelBoxModal');
            const nameInput = document.getElementById('editLabelBoxName');
            const fontSizeSelect = document.getElementById('editLabelBoxFontSize');
            
            // Populate with current values
            const nameText = labelBoxElement.querySelector('div');
            nameInput.value = nameText ? nameText.textContent : '';
            fontSizeSelect.value = nameText ? nameText.style.fontSize || '12px' : '12px';
            
            // Find and select current icon
            const currentIcon = labelBoxElement.querySelector('i');
            if (currentIcon) {
                const currentIconClass = currentIcon.className;
                document.querySelectorAll('#editLabelBoxModal .icon-library i').forEach(icon => {
                    icon.classList.remove('selected');
                    if (icon.dataset.icon === currentIconClass) {
                        icon.classList.add('selected');
                    }
                });
            }
            
            // Find and select current shape
            const currentShape = labelBoxElement.dataset.shape;
            if (currentShape) {
                document.querySelectorAll('#editLabelBoxModal .shape-option').forEach(option => {
                    option.classList.remove('selected');
                    if (option.dataset.shape === currentShape) {
                        option.classList.add('selected');
                    }
                });
            }
            
            // Find and select current color
            const currentColor = labelBoxElement.style.background;
            if (currentColor) {
                document.querySelectorAll('#editLabelBoxModal .color-option').forEach(option => {
                    option.classList.remove('selected');
                    if (option.dataset.color === currentColor) {
                        option.classList.add('selected');
                    }
                });
            }
            
            // Store reference to element being edited
            modal.editingElement = labelBoxElement;
            modal.style.display = 'block';
        }

        function toggleTopMenu() {
            const controlsPanel = document.querySelector('.controls-panel');
            if (controlsPanel) {
                controlsPanel.style.display = controlsPanel.style.display === 'none' ? 'flex' : 'none';
            }
        }

        // Background Color Functions
        function applyBackgroundColors() {
            const workflowBg = document.getElementById('workflowBgColor')?.value || '#fa709a';
            const engineBg = document.getElementById('centralEngineBgColor')?.value || '#667eea';
            const smartTasksBg = document.getElementById('smartTasksBgColor')?.value || '#e74c3c';
            const nodesBg = document.getElementById('networkNodesBgColor')?.value || '#ffffff';
            const labelsBg = document.getElementById('textLabelsBgColor')?.value || '#ecf0f1';
            const pageBg = document.getElementById('pageBgColor')?.value || '#667eea';
            
            document.querySelector('.workflow-container').style.background = `linear-gradient(135deg, ${workflowBg} 0%, #fee140 100%)`;
            document.querySelector('.central-engine').style.background = `linear-gradient(135deg, ${engineBg}, #764ba2)`;
            document.querySelector('.smart-tasks').style.background = smartTasksBg;
            document.querySelectorAll('.network-node').forEach(node => {
                node.style.background = nodesBg;
            });
            document.querySelectorAll('.node-label').forEach(label => {
                label.style.background = labelsBg;
            });
            document.body.style.background = `linear-gradient(135deg, ${pageBg} 0%, #764ba2 100%)`;
            
            // Save colors
            localStorage.setItem('workflowColors', JSON.stringify({
                workflowBg, engineBg, smartTasksBg, nodesBg, labelsBg, pageBg
            }));
        }

        function resetBackgroundColors() {
            document.getElementById('workflowBgColor').value = '#fa709a';
            document.getElementById('centralEngineBgColor').value = '#667eea';
            document.getElementById('smartTasksBgColor').value = '#e74c3c';
            document.getElementById('networkNodesBgColor').value = '#ffffff';
            document.getElementById('textLabelsBgColor').value = '#ecf0f1';
            document.getElementById('pageBgColor').value = '#667eea';
            
            applyBackgroundColors();
        }

        // Save and Load Layout
        function saveLayout() {
            const layout = {
                centralEngine: {
                    left: document.querySelector('.central-engine')?.style.left,
                    top: document.querySelector('.central-engine')?.style.top
                },
                smartTasks: {
                    left: document.querySelector('.smart-tasks')?.style.left,
                    top: document.querySelector('.smart-tasks')?.style.top
                },
                networkNodes: [],
                textLabels: [],
                customLabelBoxes: [],
                lines: []
            };
            
            // Save network nodes
            document.querySelectorAll('.network-node').forEach((node, index) => {
                const icon = node.querySelector('i');
                layout.networkNodes.push({
                    left: node.style.left,
                    top: node.style.top,
                    width: node.style.width,
                    height: node.style.height,
                    iconSize: icon ? icon.style.fontSize : '24px',
                    zIndex: node.style.zIndex
                });
            });
            
            // Save text labels and text boxes
            document.querySelectorAll('.node-label, .text-box').forEach((label, index) => {
                // Get only the text content, excluding resize handles
                let textContent = '';
                const textNodes = Array.from(label.childNodes).filter(node => 
                    node.nodeType === Node.TEXT_NODE || 
                    (node.nodeType === Node.ELEMENT_NODE && !node.classList.contains('resize-handle'))
                );
                
                textNodes.forEach(node => {
                    if (node.nodeType === Node.TEXT_NODE) {
                        textContent += node.textContent;
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        textContent += node.textContent;
                    }
                });
                
                layout.textLabels.push({
                    left: label.style.left,
                    top: label.style.top,
                    content: textContent, // Save only text content, not HTML with resize handles
                    fontSize: label.style.fontSize,
                    fontFamily: label.style.fontFamily,
                    color: label.style.color,
                    className: label.className, // Save the class name to distinguish between types
                    width: label.style.width,
                    height: label.style.height,
                    zIndex: label.style.zIndex
                });
            });
            
            // Save custom label boxes
            document.querySelectorAll('.custom-label-box').forEach((box, index) => {
                const icon = box.querySelector('i');
                const text = box.querySelector('div');
                layout.customLabelBoxes.push({
                    left: box.style.left,
                    top: box.style.top,
                    width: box.style.width,
                    height: box.style.height,
                    fontSize: text ? text.style.fontSize : box.style.fontSize,
                    fontFamily: box.style.fontFamily,
                    color: box.style.color,
                    iconSize: icon ? icon.style.fontSize : '20px',
                    iconClass: icon ? icon.className : '',
                    textContent: text ? text.textContent : '',
                    shape: box.dataset.shape,
                    background: box.style.background,
                    zIndex: box.style.zIndex
                });
            });
            
            // Save lines
            document.querySelectorAll('.workflow-line').forEach((line, index) => {
                layout.lines.push({
                    left: line.style.left,
                    top: line.style.top,
                    width: line.style.width,
                    height: line.style.height,
                    transform: line.style.transform,
                    lineType: line.dataset.lineType,
                    lineColor: line.dataset.lineColor,
                    lineThickness: line.dataset.lineThickness,
                    curveHeight: line.dataset.curveHeight,
                    curveDirection: line.dataset.curveDirection,
                    zIndex: line.style.zIndex
                });
            });
            
            localStorage.setItem('workflowLayout', JSON.stringify(layout));
        }

        function loadLayout() {
            try {
                const savedLayout = localStorage.getItem('workflowLayout');
                if (savedLayout) {
                    const layout = JSON.parse(savedLayout);
                    
                    // Load central engine position
                    if (layout.centralEngine && layout.centralEngine.left) {
                        document.querySelector('.central-engine').style.left = layout.centralEngine.left;
                        document.querySelector('.central-engine').style.top = layout.centralEngine.top;
                    }
                    
                    // Load smart tasks position
                    if (layout.smartTasks && layout.smartTasks.left) {
                        document.querySelector('.smart-tasks').style.left = layout.smartTasks.left;
                        document.querySelector('.smart-tasks').style.top = layout.smartTasks.top;
                    }
                    
                    // Load network nodes positions and sizes
                    if (layout.networkNodes) {
                        const nodes = document.querySelectorAll('.network-node');
                        layout.networkNodes.forEach((nodeData, index) => {
                            if (nodes[index] && nodeData.left) {
                                nodes[index].style.left = nodeData.left;
                                nodes[index].style.top = nodeData.top;
                                if (nodeData.width) {
                                    nodes[index].style.width = nodeData.width;
                                }
                                if (nodeData.height) {
                                    nodes[index].style.height = nodeData.height;
                                }
                                if (nodeData.iconSize) {
                                    const icon = nodes[index].querySelector('i');
                                    if (icon) {
                                        icon.style.fontSize = nodeData.iconSize;
                                    }
                                }
                                if (nodeData.zIndex) {
                                    nodes[index].style.zIndex = nodeData.zIndex;
                                }
                            }
                        });
                    }
                    
                    // Load text labels positions and content
                    if (layout.textLabels) {
                        const existingLabels = document.querySelectorAll('.node-label, .text-box');
                        const container = document.querySelector('.workflow-container');
                        
                        layout.textLabels.forEach((labelData, index) => {
                            let labelElement;
                            
                            // Check if this is an existing label or a dynamically created text box
                            if (index < existingLabels.length && existingLabels[index]) {
                                // Use existing element
                                labelElement = existingLabels[index];
                            } else if (labelData.className && labelData.className.includes('text-box')) {
                                // Create new text box element for dynamically created ones
                                labelElement = document.createElement('div');
                                labelElement.className = 'text-box';
                                container.appendChild(labelElement);
                                
                                // Make it draggable, editable, and resizable
                                labelElement.addEventListener('mousedown', startDrag);
                                labelElement.addEventListener('touchstart', startDrag);
                                labelElement.addEventListener('dblclick', startEditing);
                                
                                // Add click event for selection and keyboard shortcuts
                                labelElement.addEventListener('click', function(e) {
                                    e.stopPropagation();
                                    // Remove selected class from all elements
                                    document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                                    // Add selected class to clicked element
                                    labelElement.classList.add('selected');
                                });
                                
                                makeResizable(labelElement);
                            } else {
                                // Skip if we can't determine the type
                                return;
                            }
                            
                            // Apply saved properties
                            if (labelData.left) {
                                labelElement.style.left = labelData.left;
                            }
                            if (labelData.top) {
                                labelElement.style.top = labelData.top;
                            }
                            if (labelData.width) {
                                labelElement.style.width = labelData.width;
                            }
                            if (labelData.height) {
                                labelElement.style.height = labelData.height;
                            }
                            if (labelData.content) {
                                // Convert line breaks to HTML and set as innerHTML
                                const contentWithBreaks = labelData.content.replace(/\n/g, '<br>');
                                labelElement.innerHTML = contentWithBreaks;
                            }
                            if (labelData.fontSize) {
                                labelElement.style.fontSize = labelData.fontSize;
                            }
                            if (labelData.fontFamily) {
                                labelElement.style.fontFamily = labelData.fontFamily;
                            }
                            if (labelData.color) {
                                labelElement.style.color = labelData.color;
                            }
                            if (labelData.zIndex) {
                                labelElement.style.zIndex = labelData.zIndex;
                            }
                        });
                    }
                    
                    // Load custom label boxes
                    if (layout.customLabelBoxes) {
                        const existingBoxes = document.querySelectorAll('.custom-label-box');
                        const container = document.querySelector('.workflow-container');
                        
                        layout.customLabelBoxes.forEach((boxData, index) => {
                            let boxElement;
                            
                            // Check if this is an existing box or a dynamically created one
                            if (index < existingBoxes.length && existingBoxes[index]) {
                                // Use existing element
                                boxElement = existingBoxes[index];
                            } else {
                                // Create new custom label box element for dynamically created ones
                                boxElement = document.createElement('div');
                                boxElement.className = 'custom-label-box';
                                boxElement.style.position = 'absolute';
                                boxElement.style.display = 'flex';
                                boxElement.style.flexDirection = 'column';
                                boxElement.style.alignItems = 'center';
                                boxElement.style.justifyContent = 'center';
                                boxElement.style.cursor = 'move';
                                
                                // Apply shape if specified
                                if (boxData.shape) {
                                    boxElement.dataset.shape = boxData.shape;
                                    if (boxData.shape === 'circle') {
                                        boxElement.style.borderRadius = '50%';
                                    } else if (boxData.shape === 'square') {
                                        boxElement.style.borderRadius = '0';
                                    } else if (boxData.shape === 'rectangle') {
                                        boxElement.style.borderRadius = '10px';
                                    } else if (boxData.shape === 'rounded-rectangle') {
                                        boxElement.style.borderRadius = '20px';
                                    } else if (boxData.shape === 'diamond') {
                                        boxElement.style.clipPath = 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)';
                                    } else if (boxData.shape === 'hexagon') {
                                        boxElement.style.clipPath = 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)';
                                    } else if (boxData.shape === 'triangle') {
                                        boxElement.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
                                    }
                                }
                                
                                // Add icon if specified
                                if (boxData.iconClass) {
                                    const icon = document.createElement('i');
                                    icon.className = boxData.iconClass;
                                    icon.style.color = 'white';
                                    icon.style.marginBottom = '5px';
                                    icon.style.pointerEvents = 'none';
                                    if (boxData.iconSize) {
                                        icon.style.fontSize = boxData.iconSize;
                                    }
                                    boxElement.appendChild(icon);
                                }
                                
                                // Add text if specified
                                if (boxData.textContent) {
                                    const nameText = document.createElement('div');
                                    nameText.textContent = boxData.textContent;
                                    nameText.style.color = 'white';
                                    nameText.style.fontWeight = 'bold';
                                    nameText.style.textAlign = 'center';
                                    nameText.style.pointerEvents = 'none';
                                    if (boxData.fontSize) {
                                        nameText.style.fontSize = boxData.fontSize;
                                    }
                                    if (boxData.fontFamily) {
                                        nameText.style.fontFamily = boxData.fontFamily;
                                    }
                                    if (boxData.color) {
                                        nameText.style.color = boxData.color;
                                    }
                                    boxElement.appendChild(nameText);
                                }
                                
                                container.appendChild(boxElement);
                                
                                // Make it draggable, editable, and resizable
                                boxElement.addEventListener('mousedown', startDrag);
                                boxElement.addEventListener('touchstart', startDrag);
                                boxElement.addEventListener('dblclick', startEditing);
                                
                                // Add click event for selection and keyboard shortcuts
                                boxElement.addEventListener('click', function(e) {
                                    e.stopPropagation();
                                    // Remove selected class from all elements
                                    document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                                    // Add selected class to clicked element
                                    boxElement.classList.add('selected');
                                });
                                
                                makeResizable(boxElement);
                            }
                            
                            // Apply saved properties
                            if (boxData.left) {
                                boxElement.style.left = boxData.left;
                            }
                            if (boxData.top) {
                                boxElement.style.top = boxData.top;
                            }
                            if (boxData.width) {
                                boxElement.style.width = boxData.width;
                            }
                            if (boxData.height) {
                                boxElement.style.height = boxData.height;
                            }
                            if (boxData.background) {
                                boxElement.style.background = boxData.background;
                            }
                            if (boxData.zIndex) {
                                boxElement.style.zIndex = boxData.zIndex;
                            }
                        });
                    }
                    
                    // Load lines
                    if (layout.lines) {
                        layout.lines.forEach((lineData) => {
                            if (lineData.lineType && lineData.lineColor && lineData.lineThickness) {
                                // Create the line element
                                const newLine = document.createElement('div');
                                newLine.className = 'workflow-line';
                                newLine.dataset.lineType = lineData.lineType;
                                newLine.dataset.lineColor = lineData.lineColor;
                                newLine.dataset.lineThickness = lineData.lineThickness;
                                if (lineData.curveHeight) {
                                    newLine.dataset.curveHeight = lineData.curveHeight;
                                }
                                if (lineData.curveDirection) {
                                    newLine.dataset.curveDirection = lineData.curveDirection;
                                }
                                
                                // Set position and size
                                newLine.style.left = lineData.left || '100px';
                                newLine.style.top = lineData.top || '100px';
                                if (lineData.lineType === 'circle' || lineData.lineType === 'square') {
                                    newLine.style.width = lineData.width || '150px';
                                    newLine.style.height = lineData.height || '150px';
                                } else {
                                    newLine.style.width = lineData.width || '300px';
                                    newLine.style.height = lineData.height || '100px';
                                }
                                if (lineData.transform) {
                                    newLine.style.transform = lineData.transform;
                                }
                                
                                // Apply styling
                                applyLineStyling(newLine, lineData.lineType, lineData.lineColor, lineData.lineThickness);
                                
                                // Add endpoints (positioned differently for shapes vs lines)
                                const startEndpoint = document.createElement('div');
                                startEndpoint.className = 'line-endpoint';
                                const endEndpoint = document.createElement('div');
                                endEndpoint.className = 'line-endpoint';
                                
                                if (lineData.lineType === 'circle' || lineData.lineType === 'square') {
                                    // For shapes, position endpoints at the edges for resizing
                                    startEndpoint.style.left = '0px';
                                    startEndpoint.style.top = '75px';
                                    startEndpoint.dataset.endpoint = 'start';
                                    
                                    endEndpoint.style.right = '0px';
                                    endEndpoint.style.top = '75px';
                                    endEndpoint.dataset.endpoint = 'end';
                                } else {
                                    // For lines, position endpoints at the line ends
                                    startEndpoint.style.left = '50px';
                                    startEndpoint.style.top = '50px';
                                    startEndpoint.dataset.endpoint = 'start';
                                    
                                    endEndpoint.style.right = '50px';
                                    endEndpoint.style.top = '50px';
                                    endEndpoint.dataset.endpoint = 'end';
                                }
                                
                                newLine.appendChild(startEndpoint);
                                newLine.appendChild(endEndpoint);
                                
                                // Add curve control points for curved lines
                                if (lineData.lineType === 'curved') {
                                    // Main curve control (center) - positioned within container bounds
                                    const curveControl = document.createElement('div');
                                    curveControl.className = 'line-endpoint curve-control';
                                    curveControl.style.left = '50%';
                                    curveControl.style.top = '30px'; // Position within smaller container
                                    curveControl.style.transform = 'translateX(-50%)';
                                    curveControl.dataset.endpoint = 'curve';
                                    curveControl.title = 'Drag to adjust curve height';
                                    
                                    // Direction control (for curve direction) - positioned within container bounds
                                    const directionControl = document.createElement('div');
                                    directionControl.className = 'line-endpoint direction-control';
                                    directionControl.style.left = '50%';
                                    directionControl.style.top = '70px'; // Position within smaller container
                                    directionControl.style.transform = 'translateX(-50%)';
                                    directionControl.dataset.endpoint = 'direction';
                                    directionControl.title = 'Click to flip curve direction';
                                    
                                    newLine.appendChild(curveControl);
                                    newLine.appendChild(directionControl);
                                    
                                    curveControl.addEventListener('mousedown', startCurveControlDrag);
                                    directionControl.addEventListener('mousedown', startDirectionControlDrag);
                                }
                                
                                // Add rotation control for all line types
                                const rotationControl = document.createElement('div');
                                rotationControl.className = 'line-endpoint rotation-control';
                                rotationControl.style.left = '50%';
                                rotationControl.style.top = '50%';
                                rotationControl.style.transform = 'translate(-50%, -50%)';
                                rotationControl.dataset.endpoint = 'rotation';
                                rotationControl.title = 'Drag to rotate line';
                                
                                newLine.appendChild(rotationControl);
                                rotationControl.addEventListener('mousedown', startRotationDrag);
                                
                                // Add to container
                                const container = document.querySelector('.workflow-container');
                                container.appendChild(newLine);
                                
                                // Make it draggable and editable
                                newLine.addEventListener('mousedown', startLineDrag);
                                newLine.addEventListener('click', () => selectLine(newLine));
                                
                                // Add endpoint drag functionality
                                startEndpoint.addEventListener('mousedown', (e) => startEndpointDrag(e, newLine, true));
                                endEndpoint.addEventListener('mousedown', (e) => startEndpointDrag(e, newLine, false));
                                
                                // Ensure line visibility after loading
                                ensureLineVisibility(newLine);
                                
                                // Restore z-index if saved
                                if (lineData.zIndex) {
                                    newLine.style.zIndex = lineData.zIndex;
                                }
                            }
                        });
                    }
                }
                
                // Load saved colors
                const savedColors = localStorage.getItem('workflowColors');
                if (savedColors) {
                    const colors = JSON.parse(savedColors);
                    document.getElementById('workflowBgColor').value = colors.workflowBg || '#fa709a';
                    document.getElementById('centralEngineBgColor').value = colors.engineBg || '#667eea';
                    document.getElementById('smartTasksBgColor').value = colors.smartTasksBg || '#e74c3c';
                    document.getElementById('networkNodesBgColor').value = colors.nodesBg || '#ffffff';
                    document.getElementById('textLabelsBgColor').value = colors.labelsBg || '#ecf0f1';
                    document.getElementById('pageBgColor').value = colors.pageBg || '#667eea';
                    applyBackgroundColors();
                }
            } catch (error) {
                console.error('Error loading layout:', error);
            }
        }

        // Controls Functionality
        function initControls() {
            const startBtn = document.getElementById('startBtn');
            const resetBtn = document.getElementById('resetBtn');
            const saveBtn = document.getElementById('saveBtn');
            const loadBtn = document.getElementById('loadBtn');
            
            if (startBtn) {
                startBtn.addEventListener('click', function() {
                    alert('Start functionality - you can implement workflow animation here');
                });
            }
            
            if (resetBtn) {
                resetBtn.addEventListener('click', function() {
                    if (confirm('Are you sure you want to reset the layout?')) {
                        localStorage.removeItem('workflowLayout');
                        location.reload();
                    }
                });
            }
            
            if (saveBtn) {
                saveBtn.addEventListener('click', function() {
                    saveLayout();
                    alert('Layout saved successfully!');
                });
            }
            
            if (loadBtn) {
                loadBtn.addEventListener('click', function() {
                    loadLayout();
                    alert('Layout loaded successfully!');
                });
            }
        }

        // Title functionality variables
        let isTitleDragging = false;
        let isTitleResizing = false;
        let titleDragOffset = { x: 0, y: 0 };
        let titleResizeStart = { x: 0, y: 0, width: 0, height: 0, fontSize: 0 };

        // Initialize title functionality
        function initTitleFunctionality() {
            const title = document.getElementById('workflowTitle');
            const resizeHandle = title.querySelector('.resize-handle');
            
            // Make title draggable
            title.addEventListener('mousedown', startTitleDrag);
            
            // Make title resizable via handle
            if (resizeHandle) {
                resizeHandle.addEventListener('mousedown', startTitleResize);
            }
            
            // Right-click context menu
            title.addEventListener('contextmenu', showTitleContextMenu);
            
            // Double-click to edit (keep existing functionality)
            title.addEventListener('dblclick', editTitleText);
            
            // Add click event for selection and keyboard shortcuts
            title.addEventListener('click', function(e) {
                e.stopPropagation();
                // Remove selected class from all elements
                document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                // Add selected class to title element
                title.classList.add('selected');
                console.log('Title selected for keyboard shortcuts');
            });
            
            // Hide context menu when clicking elsewhere
            document.addEventListener('click', hideTitleContextMenu);
        }

        function startTitleDrag(e) {
            if (e.target.classList.contains('resize-handle')) return;
            
            e.preventDefault();
            isTitleDragging = true;
            
            const title = document.getElementById('workflowTitle');
            const rect = title.getBoundingClientRect();
            
            titleDragOffset.x = e.clientX - rect.left;
            titleDragOffset.y = e.clientY - rect.top;
            
            title.classList.add('dragging');
            
            document.addEventListener('mousemove', onTitleDrag);
            document.addEventListener('mouseup', stopTitleDrag);
        }

        function onTitleDrag(e) {
            if (!isTitleDragging) return;
            
            const title = document.getElementById('workflowTitle');
            const newX = e.clientX - titleDragOffset.x;
            const newY = e.clientY - titleDragOffset.y;
            
            // Allow free positioning - no boundary restrictions
            title.style.left = newX + 'px';
            title.style.top = newY + 'px';
            title.style.transform = 'none'; // Remove centering transform
            
            // Always keep title in front since it can be moved anywhere
            title.style.zIndex = '2000';
        }

        function stopTitleDrag() {
            isTitleDragging = false;
            const title = document.getElementById('workflowTitle');
            title.classList.remove('dragging');
            
            document.removeEventListener('mousemove', onTitleDrag);
            document.removeEventListener('mouseup', stopTitleDrag);
            
            saveTitlePosition();
        }

        function startTitleResize(e) {
            e.preventDefault();
            e.stopPropagation();
            
            isTitleResizing = true;
            const title = document.getElementById('workflowTitle');
            const rect = title.getBoundingClientRect();
            const computedStyle = window.getComputedStyle(title);
            
            titleResizeStart.x = e.clientX;
            titleResizeStart.y = e.clientY;
            titleResizeStart.width = rect.width;
            titleResizeStart.height = rect.height;
            titleResizeStart.fontSize = parseFloat(computedStyle.fontSize);
            
            title.classList.add('resizing');
            
            document.addEventListener('mousemove', onTitleResize);
            document.addEventListener('mouseup', stopTitleResize);
        }

        function onTitleResize(e) {
            if (!isTitleResizing) return;
            
            const title = document.getElementById('workflowTitle');
            const deltaX = e.clientX - titleResizeStart.x;
            const deltaY = e.clientY - titleResizeStart.y;
            
            // Calculate new size based on diagonal drag
            const scaleFactor = 1 + (deltaX + deltaY) / 200;
            const newFontSize = Math.max(1, titleResizeStart.fontSize * scaleFactor);
            
            title.style.fontSize = newFontSize + 'px';
        }

        function stopTitleResize() {
            isTitleResizing = false;
            const title = document.getElementById('workflowTitle');
            title.classList.remove('resizing');
            
            document.removeEventListener('mousemove', onTitleResize);
            document.removeEventListener('mouseup', stopTitleResize);
            
            saveTitlePosition();
        }

        function showTitleContextMenu(e) {
            e.preventDefault();
            const contextMenu = document.getElementById('titleContextMenu');
            contextMenu.style.display = 'block';
            contextMenu.style.left = e.pageX + 'px';
            contextMenu.style.top = e.pageY + 'px';
        }

        function hideTitleContextMenu(e) {
            const contextMenu = document.getElementById('titleContextMenu');
            const titleContextMenu = document.getElementById('titleContextMenu');
            
            if (!titleContextMenu.contains(e.target)) {
                contextMenu.style.display = 'none';
            }
        }

        function editTitleText() {
            const title = document.getElementById('workflowTitle');
            const currentText = title.textContent.trim();
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentText;
            input.className = 'editing-input';
            
            // Clear title content but keep resize handle
            const resizeHandle = title.querySelector('.resize-handle');
            title.innerHTML = '';
            title.appendChild(input);
            if (resizeHandle) {
                title.appendChild(resizeHandle);
            }
            
            input.focus();
            input.select();
            
            input.addEventListener('blur', finishTitleEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }

        function finishTitleEdit() {
            const title = document.getElementById('workflowTitle');
            const input = title.querySelector('input');
            const newText = input.value || 'Intelligent Message Data Engine';
            
            // Keep resize handle
            const resizeHandle = title.querySelector('.resize-handle');
            title.innerHTML = newText;
            if (resizeHandle) {
                title.appendChild(resizeHandle);
            }
            
            saveTitlePosition();
        }

        function resetTitlePosition() {
            const title = document.getElementById('workflowTitle');
            title.style.left = '50%';
            title.style.top = '20px';
            title.style.transform = 'translateX(-50%)';
            title.style.fontSize = '2.5rem';
            saveTitlePosition();
        }

        // Keyboard Shortcuts Functionality
        function initKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Only handle shortcuts when no input/textarea is focused
                if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
                    return;
                }
                
                const selectedElement = document.querySelector('.selected');
                
                // Delete key
                if (e.key === 'Delete') {
                    if (selectedElement) {
                        // Check if it's a deletable element (not central-engine or smart-tasks)
                        if (!selectedElement.classList.contains('central-engine') && 
                            selectedElement.id !== 'smartTasks') {
                            selectedElement.remove();
                            saveLayout();
                        }
                    }
                }
                
                // Copy (Ctrl+C)
                if (e.ctrlKey && e.key === 'c') {
                    e.preventDefault();
                    if (selectedElement) {
                        copyElement(selectedElement);
                        console.log('Element copied via keyboard shortcut');
                    }
                }
                
                // Paste (Ctrl+V)
                if (e.ctrlKey && e.key === 'v') {
                    e.preventDefault();
                    pasteElement();
                    console.log('Element pasted via keyboard shortcut');
                }
            });
        }

        function saveTitlePosition() {
            const title = document.getElementById('workflowTitle');
            const titleData = {
                left: title.style.left,
                top: title.style.top,
                transform: title.style.transform,
                fontSize: title.style.fontSize,
                text: title.textContent.trim()
            };
            localStorage.setItem('titlePosition', JSON.stringify(titleData));
        }

        function loadTitlePosition() {
            const savedData = localStorage.getItem('titlePosition');
            if (savedData) {
                const titleData = JSON.parse(savedData);
                const title = document.getElementById('workflowTitle');
                
                if (titleData.left) title.style.left = titleData.left;
                if (titleData.top) title.style.top = titleData.top;
                if (titleData.transform) title.style.transform = titleData.transform;
                if (titleData.fontSize) title.style.fontSize = titleData.fontSize;
                if (titleData.text && titleData.text !== title.textContent.trim()) {
                    const resizeHandle = title.querySelector('.resize-handle');
                    title.innerHTML = titleData.text;
                    if (resizeHandle) {
                        title.appendChild(resizeHandle);
                    }
                }
            }
        }

        // Title context menu event handlers
        document.addEventListener('DOMContentLoaded', function() {
            const titleContextMenu = document.getElementById('titleContextMenu');
            
            titleContextMenu.addEventListener('click', function(e) {
                const action = e.target.dataset.action;
                
                switch (action) {
                    case 'editTitle':
                        editTitleText();
                        break;
                    case 'resizeTitle':
                        // Already handled by resize handle
                        alert('Use the resize handle in the bottom-right corner of the title, or drag diagonally to resize.');
                        break;
                    case 'resetTitlePosition':
                        resetTitlePosition();
                        break;
                }
                
                titleContextMenu.style.display = 'none';
            });
            
            // Initialize title functionality
            initTitleFunctionality();
            loadTitlePosition();
        });
    </script>
</body>
</html>

